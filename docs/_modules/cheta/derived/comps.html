
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cheta.derived.comps &#8212; Eng archive 4.59.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-astropy.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">Ska! </span><span id="logotext2">Cheta</span><span id="logotext3"></span></a>
  <ul>
    
    <li><a class="home" title="Homepage" href="https://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc">
        <span id="logotext1">ska</span><span id="logotext2">tools</span>
    </a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Eng archive 4.59.0 documentation</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cheta.derived.comps</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Support computed MSIDs in the cheta archive.</span>

<span class="sd">- :class:`~cheta.derived.comps.ComputedMsid`: base class for user-generated comps.</span>
<span class="sd">- :class:`~cheta.derived.comps.Comp_MUPS_Valve_Temp_Clean`:</span>
<span class="sd">  Cleaned MUPS valve temperatures MSIDs ``(pm2thv1t|pm1thv2t)_clean``.</span>
<span class="sd">- :class:`~cheta.derived.comps.Comp_KadiCommandState`:</span>
<span class="sd">  Commanded states ``cmd_state_&lt;key&gt;_&lt;dt&gt;`` for any kadi commanded state value.</span>
<span class="sd">- :class:`~cheta.derived.comps.Comp_Quat`:</span>
<span class="sd">  Quaternions</span>
<span class="sd">    - ``quat_aoattqt`` = ``AOATTQT[1-4]``</span>
<span class="sd">    - ``quat_aoatupq`` = ``AOATUPQ[1-3]``</span>
<span class="sd">    - ``quat_aocmdqt`` = ``AOCMDQT[1-3]``</span>
<span class="sd">    - ``quat_aotarqt`` = ``AOTARQT[1-3]``</span>
<span class="sd">- :class:`~cheta.derived.comps.Comp_Pitch_Roll_OBC_Safe`:</span>
<span class="sd">  Sun Pitch ``pitch_comp`` and off-nominal roll ``roll_comp`` which are valid in NPNT,</span>
<span class="sd">  NMAN, NSUN and safe mode.</span>

<span class="sd">See: https://nbviewer.jupyter.org/urls/cxc.harvard.edu/mta/ASPECT/ipynb/misc/DAWG-mups-valve-xija-filtering.ipynb</span>
<span class="sd">&quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">astropy.table</span> <span class="k">as</span> <span class="nn">tbl</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cxotime</span> <span class="kn">import</span> <span class="n">CxoTime</span>

<span class="kn">from</span> <span class="nn">..units</span> <span class="kn">import</span> <span class="n">converters</span> <span class="k">as</span> <span class="n">unit_converter_funcs</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;ComputedMsid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Comp_MUPS_Valve_Temp_Clean&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Comp_KadiCommandState&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Comp_Pitch_Roll_OBC_Safe&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Comp_Quat&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">calc_stats_vals</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute statistics values for ``msid`` over specified intervals.</span>
<span class="sd">    This is a very slightly modified version of the same function from</span>
<span class="sd">    update_archive.py.  However, cannot directly import that because</span>
<span class="sd">    it has side effects that break everything, probably related to</span>
<span class="sd">    enabling caching.</span>

<span class="sd">    The mods here are basically to take out handling of state codes</span>
<span class="sd">    and turn a warning about negative dts into an exception.</span>

<span class="sd">    :param msid: Msid object (filter_bad=True)</span>
<span class="sd">    :param rows: Msid row indices corresponding to stat boundaries</span>
<span class="sd">    :param indexes: Universal index values for stat (row times // dt)</span>
<span class="sd">    :param interval: interval name (5min or daily)</span>

<span class="sd">    :returns: np.recarray of stats values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.stats</span>

    <span class="n">quantiles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
    <span class="n">n_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Check if data type is &quot;numeric&quot;.  Boolean values count as numeric,</span>
    <span class="c1"># partly for historical reasons, in that they support funcs like</span>
    <span class="c1"># mean (with implicit conversion to float).</span>
    <span class="n">msid_dtype</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">msid_is_numeric</span> <span class="o">=</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">msid_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span>

    <span class="c1"># If MSID data is unicode, then for stats purposes cast back to bytes</span>
    <span class="c1"># by creating the output array as a like-sized S-type array.</span>
    <span class="k">if</span> <span class="n">msid_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;U&quot;</span><span class="p">:</span>
        <span class="n">msid_dtype</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">msid</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">)</span>

    <span class="c1"># Predeclare numpy arrays of correct type and sufficient size for accumulating results.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">msid_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">msid_is_numeric</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">msid_dtype</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">msid_dtype</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="s2">&quot;daily&quot;</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">msid_dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="n">quantiles</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;p</span><span class="si">{:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quantile</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n_out</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">msid_dtype</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">row0</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rows</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">indexes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">]</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">]</span>

        <span class="n">n_vals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_vals</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">n_vals</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">msid_is_numeric</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_vals</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">dts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">dts</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">negs</span> <span class="o">=</span> <span class="n">dts</span> <span class="o">&lt;</span> <span class="mf">0.0</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">negs</span><span class="p">):</span>
                        <span class="n">times_dts</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">(</span><span class="n">CxoTime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">negs</span><span class="p">],</span> <span class="n">dts</span><span class="p">[</span><span class="n">negs</span><span class="p">])</span>
                        <span class="p">]</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;WARNING - negative dts in </span><span class="si">{}</span><span class="s2"> at </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">msid</span><span class="o">.</span><span class="n">MSID</span><span class="p">,</span> <span class="n">times_dts</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># Clip to range 0.001 to 300.0.  The low bound is just there</span>
                    <span class="c1"># for data with identical time stamps.  This shouldn&#39;t happen</span>
                    <span class="c1"># but in practice might.  The 300.0 represents 5 minutes and</span>
                    <span class="c1"># is the largest normal time interval.  Data near large gaps</span>
                    <span class="c1"># will get a weight of 5 mins.</span>
                    <span class="n">dts</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">300.0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">dts</span><span class="p">)</span>
                <span class="n">sum_dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>

                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dts</span> <span class="o">*</span> <span class="n">vals</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_dts</span>
                <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="s2">&quot;daily&quot;</span><span class="p">:</span>
                    <span class="c1"># biased weighted estimator of variance (N should be big enough)</span>
                    <span class="c1"># http://en.wikipedia.org/wiki/Mean_square_weighted_deviation</span>
                    <span class="n">sigma_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dts</span> <span class="o">*</span> <span class="p">(</span><span class="n">vals</span> <span class="o">-</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_dts</span>
                    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_sq</span><span class="p">)</span>
                    <span class="n">quant_vals</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">mquantiles</span><span class="p">(</span>
                        <span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">quant_val</span><span class="p">,</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">quant_vals</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">):</span>
                        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;p</span><span class="si">%02d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">quantile</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">quant_val</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="n">names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>


<div class="viewcode-block" id="ComputedMsid"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.ComputedMsid">[docs]</a><span class="k">class</span> <span class="nc">ComputedMsid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for cheta computed MSID.</span>

<span class="sd">    Sub-classes must define at least the following:</span>

<span class="sd">    * ``msid_match`` class attribute as a regex to match for the MSID.</span>
<span class="sd">    * ``get_msid_attrs()`` method to perform the computation and return</span>
<span class="sd">      a dict with the result.</span>

<span class="sd">    Optionally:</span>

<span class="sd">    * ``units`` attribute to specify unit handling.</span>

<span class="sd">    See the fetch tutorial Computed MSIDs section for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Global dict of registered computed MSIDs</span>
    <span class="n">msid_classes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Base units specification (None implies no unit handling)</span>
    <span class="n">units</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_system</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_system</span> <span class="o">=</span> <span class="n">unit_system</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate and register ComputedMSID subclass.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;msid_match&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;comp </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define msid_match&quot;</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">msid_classes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

<div class="viewcode-block" id="ComputedMsid.get_matching_comp_cls"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.ComputedMsid.get_matching_comp_cls">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_matching_comp_cls</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">msid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get computed classes that match ``msid``</span>

<span class="sd">        :param msid: str, input msid</span>
<span class="sd">        :returns: first ComputedMsid subclass that matches ``msid`` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">comp_cls</span> <span class="ow">in</span> <span class="n">ComputedMsid</span><span class="o">.</span><span class="n">msid_classes</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">comp_cls</span><span class="o">.</span><span class="n">msid_match</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">comp_cls</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="c1"># These four properties are provided as a convenience because the module</span>
    <span class="c1"># itself cannot import fetch because this is circular.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fetch_eng</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fetch in TDB engineering units like DEGF&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">fetch_eng</span>

        <span class="k">return</span> <span class="n">fetch_eng</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fetch_sci</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fetch in scientific units like DEGC&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">fetch_sci</span>

        <span class="k">return</span> <span class="n">fetch_sci</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fetch_cxc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fetch in CXC (FITS standard) units like K&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">fetch</span>

        <span class="k">return</span> <span class="n">fetch</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fetch_sys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fetch in the unit system specified for the class&quot;&quot;&quot;</span>
        <span class="n">fetch</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;fetch_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_system</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fetch</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Emulate the fetch.MSID() API, but return a dict of MSID attributes.</span>

<span class="sd">        The returned dict turned into a proper MSID object by the upstream caller</span>
<span class="sd">        `fetch.MSID._get_comp_data()`.</span>

<span class="sd">        :param tstart: float, start time (CXC seconds)</span>
<span class="sd">        :param tstop: float, stop time (CXC seconds)</span>
<span class="sd">        :param msid: str, MSID name</span>
<span class="sd">        :param interval: str or None, stats interval (None, &#39;5min&#39;, &#39;daily&#39;)</span>

<span class="sd">        :returns: dict of MSID attributes including &#39;times&#39;, &#39;vals&#39;, &#39;bads&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parse any arguments from the input `msid`</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msid_match</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected mismatch of </span><span class="si">{</span><span class="n">msid</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">msid_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">match_args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">arg</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">interval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Call the actual user-supplied work method to compute the MSID values</span>
            <span class="n">msid_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_msid_attrs</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">match_args</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;vals&quot;</span><span class="p">,</span> <span class="s2">&quot;bads&quot;</span><span class="p">,</span> <span class="s2">&quot;times&quot;</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">msid_attrs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;computed MSID </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> failed &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to set required attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Presence of a non-None `units` class attribute means that the MSID has</span>
            <span class="c1"># units that should be converted to `self.unit_system` if required, where</span>
            <span class="c1"># unit_system is &#39;cxc&#39;, &#39;sci&#39;, or &#39;eng&#39;.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msid_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">msid_attrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msid_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stats_attrs</span><span class="p">(</span>
                <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">match_args</span><span class="p">,</span> <span class="n">interval</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">msid_attrs</span>

<div class="viewcode-block" id="ComputedMsid.convert_units"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.ComputedMsid.convert_units">[docs]</a>    <span class="k">def</span> <span class="nf">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msid_attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert required elements of ``msid_attrs`` to ``self.unit_system``.</span>

<span class="sd">        Unit_system can be one of &#39;cxc&#39;, &#39;sci&#39;, &#39;eng&#39;.</span>

<span class="sd">        :param msid_attrs: dict, input MSID attributes</span>
<span class="sd">        :param unit_system: str, unit system</span>

<span class="sd">        :returns: dict, converted MSID attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unit_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s2">&quot;internal_system&quot;</span><span class="p">]]</span>
        <span class="n">unit_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_system</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">msid_attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_new</span>

        <span class="k">if</span> <span class="n">unit_current</span> <span class="o">!=</span> <span class="n">unit_new</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s2">&quot;convert_attrs&quot;</span><span class="p">]:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_converter_funcs</span><span class="p">[</span><span class="n">unit_current</span><span class="p">,</span> <span class="n">unit_new</span><span class="p">](</span>
                    <span class="n">msid_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ComputedMsid.get_msid_attrs"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.ComputedMsid.get_msid_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">get_msid_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">msid_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the attributes required for this MSID.</span>

<span class="sd">        Get attributes for computed MSID, which must include at least</span>
<span class="sd">        ``vals``, ``bads``, ``times``, and may include additional attributes.</span>

<span class="sd">        This MUST be supplied by sub-classes.</span>

<span class="sd">        :param tstart: start time (CXC secs)</span>
<span class="sd">        :param tstop: stop time (CXC secs)</span>
<span class="sd">        :param msid: full MSID name e.g. tephin_plus_5</span>
<span class="sd">        :param msid_args: tuple of regex match groups (msid_name,)</span>
<span class="sd">        :returns: dict of MSID attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sub-class must implement get_msid_attrs()&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ComputedMsid.get_stats_attrs"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.ComputedMsid.get_stats_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">get_stats_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">match_args</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get 5-min or daily stats attributes.</span>

<span class="sd">        This is normally not overridden by sub-classes.</span>

<span class="sd">        :param tstart: start time (CXC secs)</span>
<span class="sd">        :param tstop: stop time (CXC secs)</span>
<span class="sd">        :param msid: full MSID name e.g. tephin_plus_5</span>
<span class="sd">        :param msid_args: tuple of regex match groups (msid_name,)</span>
<span class="sd">        :returns: dict of MSID attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..fetch</span> <span class="kn">import</span> <span class="n">_plural</span>

        <span class="c1"># Replicate a stripped-down version of processing in update_archive.</span>
        <span class="c1"># This produces a recarray with columns that correspond to the raw</span>
        <span class="c1"># stats HDF5 files.</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;5min&quot;</span><span class="p">:</span> <span class="mi">328</span><span class="p">,</span> <span class="s2">&quot;daily&quot;</span><span class="p">:</span> <span class="mi">86400</span><span class="p">}[</span><span class="n">interval</span><span class="p">]</span>
        <span class="n">index0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tstart</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tstop</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">index0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="p">(</span><span class="n">index1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

        <span class="n">msid_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_sys</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index0</span><span class="p">,</span> <span class="n">index1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">indexes</span> <span class="o">*</span> <span class="n">dt</span>  <span class="c1"># This is the *start* time of each bin</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">msid_obj</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>
            <span class="n">vals_stats</span> <span class="o">=</span> <span class="n">calc_stats_vals</span><span class="p">(</span><span class="n">msid_obj</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="c1"># Replicate the name munging that fetch does going from the HDF5 columns</span>
        <span class="c1"># to what is seen in a stats fetch query.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">vals_stats</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">out_key</span> <span class="o">=</span> <span class="n">_plural</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;n&quot;</span> <span class="k">else</span> <span class="s2">&quot;samples&quot;</span>
            <span class="n">out</span><span class="p">[</span><span class="n">out_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals_stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vals_stats</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;bads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals_stats</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;midvals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;vals&quot;</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;means&quot;</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msid_obj</span><span class="o">.</span><span class="n">unit</span>

        <span class="k">return</span> <span class="n">out</span></div></div>


<span class="c1">############################################################################</span>
<span class="c1">#  Built-in computed MSIDs</span>
<span class="c1">############################################################################</span>


<div class="viewcode-block" id="Comp_Quat"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_Quat">[docs]</a><span class="k">class</span> <span class="nc">Comp_Quat</span><span class="p">(</span><span class="n">ComputedMsid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computed MSID for returning the quaternion telemetry as a Quat object</span>

<span class="sd">    This defines the following computed MSIDs based on the corresponding</span>
<span class="sd">    TDB MSIDs:</span>

<span class="sd">    - ``quat_aoattqt`` = ``AOATTQT[1-4]``</span>
<span class="sd">    - ``quat_aoatupq`` = ``AOATUPQ[1-3]``</span>
<span class="sd">    - ``quat_aocmdqt`` = ``AOCMDQT[1-3]``</span>
<span class="sd">    - ``quat_aotarqt`` = ``AOTARQT[1-3]``</span>

<span class="sd">    Example::</span>

<span class="sd">      &gt;&gt;&gt; from cheta import fetch</span>
<span class="sd">      &gt;&gt;&gt; qatt = fetch.Msid(&#39;quat_aoattqt&#39;, &#39;2022:001:00:00:00&#39;, &#39;2022:001:00:00:04&#39;)</span>
<span class="sd">      &gt;&gt;&gt; qatt.vals</span>
<span class="sd">      Quat(array([[-0.07434856, -0.55918674, -0.80432653,  0.18665828],</span>
<span class="sd">                  [-0.07434854, -0.55918679, -0.8043265 ,  0.18665825],</span>
<span class="sd">                  [-0.07434849, -0.55918674, -0.80432653,  0.18665829],</span>
<span class="sd">                  [-0.07434849, -0.55918667, -0.80432653,  0.18665852]]))</span>
<span class="sd">      &gt;&gt;&gt; qatt.vals.equatorial</span>
<span class="sd">      array([[193.28905806,  19.16894296,  67.36207683],</span>
<span class="sd">             [193.28905485,  19.1689407 ,  67.36208471],</span>
<span class="sd">             [193.28906329,  19.16893787,  67.36207699],</span>
<span class="sd">             [193.28908839,  19.16895134,  67.36206404]])</span>

<span class="sd">    This computed MSID can be used with the MAUDE data source. Be aware that if the</span>
<span class="sd">    telemetry has a missing VCDU then there is a risk of getting a slightly incorrect</span>
<span class="sd">    quaternion. This would occur since the code uses nearest-neighbor interpolation to</span>
<span class="sd">    associate the four components of the quaternion with a single time. For back-orbit</span>
<span class="sd">    data this is rare, but for real-time data it is more likely.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msid_match</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;quat_(aoattqt|aoatupq|aocmdqt|aotarqt)&quot;</span>

<div class="viewcode-block" id="Comp_Quat.get_msid_attrs"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_Quat.get_msid_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">get_msid_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">tstop</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">msid</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">msid_args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">Quaternion</span> <span class="kn">import</span> <span class="n">Quat</span><span class="p">,</span> <span class="n">normalize</span>

        <span class="n">msid_root</span> <span class="o">=</span> <span class="n">msid_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_comp</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">msid_root</span> <span class="o">==</span> <span class="s2">&quot;aoattqt&quot;</span> <span class="k">else</span> <span class="mi">3</span>
        <span class="n">msids</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msid_root</span><span class="si">}{</span><span class="n">ii</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_comp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Get the raw MSIDs. Fetch a bit extra to avoid edge effects, in particular a</span>
        <span class="c1"># MAUDE query with a start time that lands between components of a quaternion.</span>
        <span class="c1"># E.g. aocmdqt* are spread over about 0.5 sec, but aoattqt seems to be within</span>
        <span class="c1"># the same minor frame.</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_sys</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">tstart</span> <span class="o">-</span> <span class="mi">35</span><span class="p">,</span> <span class="n">tstop</span> <span class="o">+</span> <span class="mi">35</span><span class="p">)</span>

        <span class="c1"># Interpolate to a common time base, leaving in flagged bad data and</span>
        <span class="c1"># marking data bad if any of the set at each time are bad. Note that this uses</span>
        <span class="c1"># nearest-neighbor interpolation. Empirically for these MSIDs that will work to</span>
        <span class="c1"># correctly bin the components together. See:</span>
        <span class="c1"># https://sot.github.io/eng_archive/fetch_tutorial.html#filtering-and-bad-values</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">msids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span> <span class="o">&gt;=</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">times</span> <span class="o">&lt;</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="n">dat</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bad_union</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">q1</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">msids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">msids</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">q3</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">msids</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_comp</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">q4</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">msids</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">q1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">q2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">q3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span><span class="p">,</span> <span class="n">q4</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">Quat</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
            <span class="n">bads</span> <span class="o">|=</span> <span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">bads</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="n">quat</span><span class="p">,</span> <span class="s2">&quot;bads&quot;</span><span class="p">:</span> <span class="n">bads</span><span class="p">,</span> <span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="n">dat</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="Comp_MUPS_Valve_Temp_Clean"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_MUPS_Valve_Temp_Clean">[docs]</a><span class="k">class</span> <span class="nc">Comp_MUPS_Valve_Temp_Clean</span><span class="p">(</span><span class="n">ComputedMsid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computed MSID for cleaned MUPS valve temps PM2THV1T, PM1THV2T</span>

<span class="sd">    This uses the cleaning method demonstrated in the following notebook</span>
<span class="sd">    to return a version of the MUPS valve temperature comprised of</span>
<span class="sd">    telemetry values that are consistent with a thermal model.</span>

<span class="sd">    https://nbviewer.jupyter.org/urls/cxc.cfa.harvard.edu/mta/ASPECT/ipynb/misc/mups-valve-xija-filtering.ipynb</span>
<span class="sd">    https://nbviewer.jupyter.org/urls/cxc.harvard.edu/mta/ASPECT/ipynb/misc/DAWG-mups-valve-xija-filtering.ipynb</span>

<span class="sd">    Allowed MSIDs are &#39;pm2thv1t_clean&#39; and &#39;pm1thv2t_clean&#39; (as always case is</span>
<span class="sd">    not important). Optionally one can include the ``chandra_models`` branch name,</span>
<span class="sd">    tag or commit hash to used for reading the MUPS 1B and MUPS 2A thermal model</span>
<span class="sd">    specifications. For example you can use &#39;pm1thv2t_clean_3.28&#39; to get the model</span>
<span class="sd">    from release 3.28 of chandra_models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msid_match</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(pm2thv1t|pm1thv2t)_clean(_[\w\.]+)?&quot;</span>

    <span class="n">units</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;internal_system&quot;</span><span class="p">:</span> <span class="s2">&quot;eng&quot;</span><span class="p">,</span>  <span class="c1"># Unit system for attrs from get_msid_attrs()</span>
        <span class="s2">&quot;eng&quot;</span><span class="p">:</span> <span class="s2">&quot;DEGF&quot;</span><span class="p">,</span>  <span class="c1"># Units for eng, sci, cxc systems</span>
        <span class="s2">&quot;sci&quot;</span><span class="p">:</span> <span class="s2">&quot;DEGC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cxc&quot;</span><span class="p">:</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span>
        <span class="c1"># Attributes that need conversion</span>
        <span class="s2">&quot;convert_attrs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;vals&quot;</span><span class="p">,</span> <span class="s2">&quot;vals_raw&quot;</span><span class="p">,</span> <span class="s2">&quot;vals_nan&quot;</span><span class="p">,</span> <span class="s2">&quot;vals_corr&quot;</span><span class="p">,</span> <span class="s2">&quot;vals_model&quot;</span><span class="p">],</span>
    <span class="p">}</span>

<div class="viewcode-block" id="Comp_MUPS_Valve_Temp_Clean.get_msid_attrs"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_MUPS_Valve_Temp_Clean.get_msid_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">get_msid_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">msid_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attributes for computed MSID: ``vals``, ``bads``, ``times``, ``unit``</span>

<span class="sd">        :param tstart: start time (CXC secs)</span>
<span class="sd">        :param tstop: stop time (CXC secs)</span>
<span class="sd">        :param msid: full MSID name e.g. pm2thv1t_clean</span>
<span class="sd">        :param msid_args: tuple of regex match groups (msid_name,)</span>

<span class="sd">        :returns: dict of MSID attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.mups_valve</span> <span class="kn">import</span> <span class="n">fetch_clean_msid</span>

        <span class="c1"># Git version of chandra_models to use for MUPS model spec from 2nd match group.</span>
        <span class="c1"># If not supplied it will be None so use default main version.</span>
        <span class="n">version</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">msid_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">msid_args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get cleaned MUPS valve temperature data as an MSID object</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">fetch_clean_msid</span><span class="p">(</span>
            <span class="n">msid_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">tstart</span><span class="p">,</span>
            <span class="n">tstop</span><span class="p">,</span>
            <span class="n">dt_thresh</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
            <span class="n">median</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
            <span class="n">model_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert to dict as required by the get_msids_attrs API.  `fetch_clean_msid`</span>
        <span class="c1"># returns an MSID object with the following attrs.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">,</span>
            <span class="s2">&quot;times&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bads&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vals_raw&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vals_nan&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vals_corr&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vals_model&quot;</span><span class="p">,</span>
            <span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">msid_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">attr</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">}</span>
        <span class="n">msid_attrs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;DEGF&quot;</span>

        <span class="k">return</span> <span class="n">msid_attrs</span></div></div>


<div class="viewcode-block" id="Comp_KadiCommandState"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_KadiCommandState">[docs]</a><span class="k">class</span> <span class="nc">Comp_KadiCommandState</span><span class="p">(</span><span class="n">ComputedMsid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computed MSID for kadi dynamic commanded states.</span>

<span class="sd">    The MSID here takes the form ``cmd_state_&lt;state_key&gt;_&lt;dt&gt;`` where:</span>

<span class="sd">    * ``state_key`` is a valid commanded state key such as ``pitch`` or</span>
<span class="sd">      ``pcad_mode`` or ``acisfp_temp``.</span>
<span class="sd">    * ``dt`` is the sampling time expressed as a multiple of 1.025 sec</span>
<span class="sd">      frames.</span>

<span class="sd">    Example MSID names::</span>

<span class="sd">      &#39;cmd_state_pcad_mode_1&#39;: sample ``pcad_mode`` every 1.025 secs</span>
<span class="sd">      &#39;cmd_state_acisfp_temp_32&#39;: sample ``acisfp_temp`` every 32.8 secs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msid_match</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;cmd_state_(\w+)_(\d+)&quot;</span>

<div class="viewcode-block" id="Comp_KadiCommandState.get_msid_attrs"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_KadiCommandState.get_msid_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">get_msid_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">msid_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attributes for computed MSID: ``vals``, ``bads``, ``times``</span>

<span class="sd">        :param tstart: start time (CXC secs)</span>
<span class="sd">        :param tstop: stop time (CXC secs)</span>
<span class="sd">        :param msid: full MSID name e.g. cmd_state_pitch_clean</span>
<span class="sd">        :param msid_args: tuple of regex match groups: (state_key, dt)</span>

<span class="sd">        :returns: dict of MSID attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Chandra.Time</span> <span class="kn">import</span> <span class="n">date2secs</span>
        <span class="kn">from</span> <span class="nn">kadi.commands.states</span> <span class="kn">import</span> <span class="n">get_states</span>

        <span class="n">state_key</span> <span class="o">=</span> <span class="n">msid_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.025</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">msid_args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">get_states</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">state_keys</span><span class="o">=</span><span class="p">[</span><span class="n">state_key</span><span class="p">])</span>

        <span class="n">tstart</span> <span class="o">=</span> <span class="n">date2secs</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;datestart&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tstops</span> <span class="o">=</span> <span class="n">date2secs</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;datestop&quot;</span><span class="p">])</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">state_key</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">tstops</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="n">vals</span><span class="p">[</span><span class="n">indexes</span><span class="p">],</span>
            <span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="n">times</span><span class="p">,</span>
            <span class="s2">&quot;bads&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="s2">&quot;unit&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">out</span></div></div>


<span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_roll_pitch_tlm_safe_table</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get telemetry values to compute pitch and roll in safe mode&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">cheta.utils</span> <span class="kn">import</span> <span class="n">get_telem_table</span>

    <span class="n">msids</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;6sares1&quot;</span><span class="p">,</span> <span class="s2">&quot;6sares2&quot;</span><span class="p">,</span> <span class="s2">&quot;6sunsa1&quot;</span><span class="p">,</span> <span class="s2">&quot;6sunsa2&quot;</span><span class="p">,</span> <span class="s2">&quot;6sunsa3&quot;</span><span class="p">]</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">get_telem_table</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

    <span class="c1"># Filter out of range values. This happens just at the beginning of safe mode.</span>
    <span class="n">bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">180</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;6sares&quot;</span> <span class="ow">in</span> <span class="n">msid</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">bads</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="n">x0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="n">x1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bads</span><span class="p">):</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="o">~</span><span class="n">bads</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">dat</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_roll_pitch_tlm_safe</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get telemetry values to compute pitch and roll in safe mode.</span>

<span class="sd">    This uses the OBC-computed sun position in the solar array frame from CSS data.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">cheta</span> <span class="kn">import</span> <span class="n">fetch</span>

    <span class="n">msids</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;6sares1&quot;</span><span class="p">,</span> <span class="s2">&quot;6sares2&quot;</span><span class="p">,</span> <span class="s2">&quot;6sunsa1&quot;</span><span class="p">,</span> <span class="s2">&quot;6sunsa2&quot;</span><span class="p">,</span> <span class="s2">&quot;6sunsa3&quot;</span><span class="p">]</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

    <span class="c1"># Filter out of range values. This happens just at the beginning of safe mode.</span>
    <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;6sares&quot;</span> <span class="ow">in</span> <span class="n">msid</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">180</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">bads</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="n">x0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="n">x1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">):</span>
        <span class="n">dat</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
            <span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dat</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dat</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">dat</span><span class="p">[</span><span class="n">msids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">bad_union</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dat</span>


<span class="k">def</span> <span class="nf">calc_css_pitch_safe</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.pcad</span> <span class="kn">import</span> <span class="n">arccos_clip</span><span class="p">,</span> <span class="n">calc_sun_vec_body_css</span>

    <span class="c1"># Get the raw telemetry value in user-requested unit system</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">get_roll_pitch_tlm_safe</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

    <span class="n">sun_vec_norm</span><span class="p">,</span> <span class="n">bads</span> <span class="o">=</span> <span class="n">calc_sun_vec_body_css</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">safe_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">arccos_clip</span><span class="p">(</span><span class="n">sun_vec_norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="o">~</span><span class="n">bads</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">calc_css_roll_safe</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Off-Nominal Roll Angle from CSS Data in ACA Frame [Deg]</span>

<span class="sd">    Defined as the rotation about the ACA X-axis required to align the sun</span>
<span class="sd">    vector with the ACA X/Z plane.</span>

<span class="sd">    Calculated by rotating the CSS sun vector from the SA-1 frame to ACA frame</span>
<span class="sd">    based on the solar array angles 6SARES1 and 6SARES2.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.pcad</span> <span class="kn">import</span> <span class="n">calc_sun_vec_body_css</span>

    <span class="c1"># Get the raw telemetry value in user-requested unit system</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">get_roll_pitch_tlm_safe</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

    <span class="n">sun_vec_norm</span><span class="p">,</span> <span class="n">bads</span> <span class="o">=</span> <span class="n">calc_sun_vec_body_css</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">safe_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">sun_vec_norm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">-</span><span class="n">sun_vec_norm</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]))</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="o">~</span><span class="n">bads</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">calc_pitch_roll_obc</span><span class="p">(</span><span class="n">tstart</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">tstop</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">pitch_roll</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use the code in the PCAD derived parameter classes to get the pitch and off</span>
<span class="sd">    nominal roll from OBC quaternion data.</span>

<span class="sd">    :param tstart: start time (CXC seconds)</span>
<span class="sd">    :param tstop: stop time (CXC seconds)</span>
<span class="sd">    :param pitch_roll: &#39;pitch&#39; or &#39;roll&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.pcad</span> <span class="kn">import</span> <span class="n">DP_PITCH</span><span class="p">,</span> <span class="n">DP_ROLL</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="n">DP_PITCH</span><span class="p">()</span> <span class="k">if</span> <span class="n">pitch_roll</span> <span class="o">==</span> <span class="s2">&quot;pitch&quot;</span> <span class="k">else</span> <span class="n">DP_ROLL</span><span class="p">()</span>
    <span class="c1"># Pad by 12 minutes on each side to ensure ephemeris data are available.</span>
    <span class="n">tlm</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">tstart</span> <span class="o">-</span> <span class="mi">720</span><span class="p">,</span> <span class="n">tstop</span> <span class="o">+</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">dp</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">tlm</span><span class="p">)</span>
    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">tlm</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">tlm</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span>


<span class="c1"># Class name is arbitrary, but by convention start with `Comp_`</span>
<div class="viewcode-block" id="Comp_Pitch_Roll_OBC_Safe"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_Pitch_Roll_OBC_Safe">[docs]</a><span class="k">class</span> <span class="nc">Comp_Pitch_Roll_OBC_Safe</span><span class="p">(</span><span class="n">ComputedMsid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computed MSID to return pitch or off-nominal roll angle which is valid in NPNT,</span>
<span class="sd">    NMAN, NSUN, and Safe Mode.</span>

<span class="sd">    MSID names are ``pitch_comp`` and ``roll_comp``.</span>

<span class="sd">    The computation logic is shown below::</span>

<span class="sd">      On OBC control (CONLOFP == &quot;NRML&quot;):</span>
<span class="sd">        - AOPCADMD in [&quot;NPNT&quot;, &quot;NMAN&quot;] =&gt; compute pitch/roll from AOATTQT[1234]</span>
<span class="sd">          (MAUDE or CXC) and predictive ephemeris ORBITEPHEM0_[XYZ] and</span>
<span class="sd">          SOLAREPHEM0_[XYZ] (CXC only but always available)</span>
<span class="sd">        - AOPCADMD == &quot;NSUN&quot; =&gt; get pitch/roll from PITCH/ROLL_CSS derived params.</span>
<span class="sd">          These are also in MAUDE.</span>

<span class="sd">      On CPE control (CONLOFP == &quot;SAFE&quot;):</span>
<span class="sd">        - Compute pitch/roll from 6SUNSA[123] + 6SARES[12] via calc_pitch/roll_css_safe()</span>

<span class="sd">      Intervals for other CONLOFP values are ignored.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msid_match</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(roll|pitch)_comp&quot;</span>

    <span class="c1"># `msid_match` is a class attribute that defines a regular expresion to</span>
    <span class="c1"># match for this computed MSID.  This must be defined and it must be</span>
    <span class="c1"># unambiguous (not matching an existing MSID or other computed MSID).</span>
    <span class="c1">#</span>
    <span class="c1"># The two groups in parentheses specify the arguments &lt;MSID&gt; and &lt;offset&gt;.</span>
    <span class="c1"># These are passed to `get_msid_attrs` as msid_args[0] and msid_args[1].</span>
    <span class="c1"># The \w symbol means to match a-z, A-Z, 0-9 and underscore (_).</span>
    <span class="c1"># The \d symbol means to match digits 0-9.</span>

<div class="viewcode-block" id="Comp_Pitch_Roll_OBC_Safe.get_msid_attrs"><a class="viewcode-back" href="../../../pseudo_msids.html#cheta.derived.comps.Comp_Pitch_Roll_OBC_Safe.get_msid_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">get_msid_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">msid_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get attributes for computed MSID: ``vals``, ``bads``, ``times``,</span>
<span class="sd">        ``unit``, ``raw_vals``, and ``offset``.  The first four must always</span>
<span class="sd">        be provided.</span>

<span class="sd">        :param tstart: start time (CXC secs)</span>
<span class="sd">        :param tstop: stop time (CXC secs)</span>
<span class="sd">        :param msid: full MSID name e.g. tephin_plus_5</span>
<span class="sd">        :param msid_args: tuple of regex match groups (msid_name,)</span>
<span class="sd">        :returns: dict of MSID attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cheta.utils</span> <span class="kn">import</span> <span class="n">get_ofp_states</span>

        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">fetch</span>
        <span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">logical_intervals</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">CxoTime</span><span class="p">(</span><span class="n">tstart</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">CxoTime</span><span class="p">(</span><span class="n">tstop</span><span class="p">)</span>

        <span class="c1"># Whether we are computing &quot;pitch&quot; or &quot;roll&quot;, parsed from MSID name</span>
        <span class="n">pitch_roll</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">msid_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ofp_states</span> <span class="o">=</span> <span class="n">get_ofp_states</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

        <span class="n">tlms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ofp_state</span> <span class="ow">in</span> <span class="n">ofp_states</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ofp_state</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NRML&quot;</span><span class="p">:</span>
                <span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s2">&quot;aopcadmd&quot;</span><span class="p">,</span> <span class="n">ofp_state</span><span class="p">[</span><span class="s2">&quot;tstart&quot;</span><span class="p">],</span> <span class="n">ofp_state</span><span class="p">[</span><span class="s2">&quot;tstop&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># For an interval with no samples put in empty arrays so that</span>
                    <span class="c1"># subsequent processing succeeds.</span>
                    <span class="n">tlms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)))</span>
                    <span class="k">continue</span>

                <span class="c1"># Get states of either NPNT / NMAN or NSUN</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;NPNT&quot;</span><span class="p">,</span> <span class="s2">&quot;NMAN&quot;</span><span class="p">])</span>
                <span class="n">states_npnt_nman</span> <span class="o">=</span> <span class="n">logical_intervals</span><span class="p">(</span>
                    <span class="n">dat</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">complete_intervals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="mf">2.1</span>
                <span class="p">)</span>
                <span class="n">states_npnt_nman</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;NPNT_NMAN&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">states_npnt_nman</span><span class="p">))</span>

                <span class="n">states_nsun</span> <span class="o">=</span> <span class="n">logical_intervals</span><span class="p">(</span>
                    <span class="n">dat</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">dat</span><span class="o">.</span><span class="n">vals</span> <span class="o">==</span> <span class="s2">&quot;NSUN&quot;</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="mf">2.1</span><span class="p">,</span> <span class="n">complete_intervals</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">states_nsun</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;NSUN&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">states_nsun</span><span class="p">))</span>
                <span class="n">states</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">states_npnt_nman</span><span class="p">,</span> <span class="n">states_nsun</span><span class="p">])</span>
                <span class="n">states</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;tstart&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NPNT_NMAN&quot;</span><span class="p">:</span>
                        <span class="n">times</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">calc_pitch_roll_obc</span><span class="p">(</span>
                            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;tstart&quot;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;tstop&quot;</span><span class="p">],</span> <span class="n">pitch_roll</span>
                        <span class="p">)</span>
                        <span class="n">tlms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NSUN&quot;</span><span class="p">:</span>
                        <span class="n">tlm</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pitch_roll</span><span class="si">}</span><span class="s2">_css&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;tstart&quot;</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;tstop&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">tlms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tlm</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tlm</span><span class="o">.</span><span class="n">vals</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">ofp_state</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SAFE&quot;</span><span class="p">:</span>
                <span class="n">calc_func</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="sa">f</span><span class="s2">&quot;calc_css_</span><span class="si">{</span><span class="n">pitch_roll</span><span class="si">}</span><span class="s2">_safe&quot;</span><span class="p">]</span>
                <span class="n">tlm</span> <span class="o">=</span> <span class="n">calc_func</span><span class="p">(</span><span class="n">ofp_state</span><span class="p">[</span><span class="s2">&quot;datestart&quot;</span><span class="p">],</span> <span class="n">ofp_state</span><span class="p">[</span><span class="s2">&quot;datestop&quot;</span><span class="p">])</span>
                <span class="n">tlms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tlm</span><span class="p">)</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">tlm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tlm</span> <span class="ow">in</span> <span class="n">tlms</span><span class="p">])</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">tlm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tlm</span> <span class="ow">in</span> <span class="n">tlms</span><span class="p">])</span>

        <span class="c1"># Return a dict with at least `vals`, `times`, `bads`, and `unit`.</span>
        <span class="c1"># Additional attributes are allowed and will be set on the</span>
        <span class="c1"># final MSID object.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;vals&quot;</span><span class="p">:</span> <span class="n">vals</span><span class="p">,</span>
            <span class="s2">&quot;bads&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="s2">&quot;times&quot;</span><span class="p">:</span> <span class="n">times</span><span class="p">,</span>
            <span class="s2">&quot;unit&quot;</span><span class="p">:</span> <span class="s2">&quot;DEG&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/ska.png" alt="Logo"/>
            </a></p><h3>Page Contents</h3>


<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011, Tom Aldcroft.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 4.2.0. &nbsp;
  </p>
</footer>
  </body>
</html>