
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ska.engarchive.fetch &#8212; Eng archive 4.53.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">Ska! </span><span id="logotext2">Cheta</span><span id="logotext3"></span></a>
  <ul>
    
    <li><a class="home" title="Homepage" href="https://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc">
        <span id="logotext1">ska</span><span id="logotext2">tools</span>
    </a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Eng archive 4.53.0 documentation</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Ska.engarchive.fetch</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fetch values from the Ska engineering telemetry archive.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">ascii</span>
<span class="kn">import</span> <span class="nn">pyyaks.context</span>

<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">file_defs</span>
<span class="kn">from</span> <span class="nn">.units</span> <span class="kn">import</span> <span class="n">Units</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">remote_access</span>
<span class="kn">from</span> <span class="nn">.remote_access</span> <span class="kn">import</span> <span class="n">ENG_ARCHIVE</span>
<span class="kn">from</span> <span class="nn">.derived.comps</span> <span class="kn">import</span> <span class="n">ComputedMsid</span>
<span class="kn">from</span> <span class="nn">.lazy</span> <span class="kn">import</span> <span class="n">LazyDict</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">__version__</span>  <span class="c1"># noqa</span>

<span class="kn">from</span> <span class="nn">Chandra.Time</span> <span class="kn">import</span> <span class="n">DateTime</span>
<span class="kn">from</span> <span class="nn">ska_helpers.utils</span> <span class="kn">import</span> <span class="n">lru_cache_timed</span>

<span class="c1"># Module-level units, defaults to CXC units (e.g. Kelvins etc)</span>
<span class="n">UNITS</span> <span class="o">=</span> <span class="n">Units</span><span class="p">(</span><span class="n">system</span><span class="o">=</span><span class="s1">&#39;cxc&#39;</span><span class="p">)</span>

<span class="c1"># Module-level control of whether MSID.fetch will cache the last 30 results</span>
<span class="n">CACHE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">IGNORE_COLNAMES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;TIME&#39;</span><span class="p">,</span> <span class="s1">&#39;MJF&#39;</span><span class="p">,</span> <span class="s1">&#39;MNF&#39;</span><span class="p">,</span> <span class="s1">&#39;TLM_FMT&#39;</span><span class="p">)</span>
<span class="n">DIR_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>

<span class="c1"># Dates near the start of 2000 that demarcates the split between the 1999 data</span>
<span class="c1"># and post-2000 data.  The 1999 data goes out to at least 2000:005:13:00:00,</span>
<span class="c1"># while post-2000 data starts as late as 2000:001:11:58:59.  Dates between LO</span>
<span class="c1"># and HI get taken from either 1999 or post-2000.  The times are 4 millisec before</span>
<span class="c1"># a minor frame boundary to avoid collisions.</span>
<span class="n">DATE2000_LO</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="s1">&#39;2000:001:00:00:00.090&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
<span class="n">DATE2000_HI</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="s1">&#39;2000:003:00:00:00.234&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>

<span class="c1"># Launch date (earliest possible date for telemetry)</span>
<span class="n">LAUNCH_DATE</span> <span class="o">=</span> <span class="s1">&#39;1999:204&#39;</span>

<span class="c1"># Maximum number of MSIDs that should ever match an input MSID spec</span>
<span class="c1"># (to prevent accidentally selecting a very large number of MSIDs)</span>
<span class="n">MAX_GLOB_MATCHES</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Special-case state codes that override those in the TDB</span>
<span class="n">STATE_CODES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># SIMDIAG</span>
    <span class="s1">&#39;3SDSWELF&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SDSYRS&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SDWMRS&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>

    <span class="c1"># SIM_MRG</span>
    <span class="s1">&#39;3TSCMOVE&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3FAMOVE&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SEAID&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;SEA-A&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;SEA-B&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SEARSET&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SEAROMF&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SEAINCM&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3STAB2EN&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;DISABLE&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ENABLE&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SMOTPEN&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ENABLE&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;DISABLE&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SMOTSEL&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;TSC&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;FA&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SHTREN&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;DISABLE&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ENABLE&#39;</span><span class="p">)],</span>
    <span class="s1">&#39;3SEARAMF&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)],</span>
<span class="p">}</span>

<span class="c1"># Cached version (by content type) of first and last available times in archive</span>
<span class="n">CONTENT_TIME_RANGES</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Default source of data.</span>
<span class="n">DEFAULT_DATA_SOURCE</span> <span class="o">=</span> <span class="s1">&#39;cxc&#39;</span>


<span class="k">class</span> <span class="nc">_DataSource</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Context manager and quasi-singleton configuration object for managing the</span>
<span class="sd">    data_source(s) used for fetching telemetry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_data_sources</span> <span class="o">=</span> <span class="p">(</span><span class="n">DEFAULT_DATA_SOURCE</span><span class="p">,)</span>
    <span class="n">_allowed</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cxc&#39;</span><span class="p">,</span> <span class="s1">&#39;maude&#39;</span><span class="p">,</span> <span class="s1">&#39;test-drop-half&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">data_sources</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_data_sources</span> <span class="o">=</span> <span class="n">data_sources</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_data_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_data_sources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_data_sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_data_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_data_sources</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">data_sources</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set current data sources.</span>

<span class="sd">        :param *data_sources: one or more sources (str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data_source</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_allowed</span> <span class="k">for</span> <span class="n">data_source</span> <span class="ow">in</span> <span class="n">data_sources</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data_sources </span><span class="si">{}</span><span class="s1"> not in allowed set </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_sources</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_allowed</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must select at least one data source in </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_allowed</span><span class="p">))</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_data_sources</span> <span class="o">=</span> <span class="n">data_sources</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sources</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">include_test</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get tuple of current data sources names.</span>

<span class="sd">        :param include_test: include sources that start with &#39;test&#39;</span>
<span class="sd">        :returns: tuple of data source names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">include_test</span><span class="p">:</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_data_sources</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_data_sources</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)]</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_msids</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the set of MSID names corresponding to ``source`` (e.g. &#39;cxc&#39; or &#39;maude&#39;)</span>

<span class="sd">        :param source: str</span>
<span class="sd">        :returns: set of MSIDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;cxc&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;maude&#39;</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">maude</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">maude</span><span class="o">.</span><span class="n">MSIDS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source must be &quot;cxc&quot; or &quot;msid&quot;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the data sources and corresponding options as a dict.</span>

<span class="sd">        Example::</span>

<span class="sd">          &gt;&gt;&gt; data_source.set(&#39;cxc&#39;, &#39;maude allow_subset=False&#39;)</span>
<span class="sd">          &gt;&gt;&gt; data_source.options()</span>
<span class="sd">          {&#39;cxc&#39;: {}, &#39;maude&#39;: {&#39;allow_subset&#39;: False}}</span>

<span class="sd">        :returns: dict of data source options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">ast</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_data_sources</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">opts</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">out</span>


<span class="c1"># Public interface is a &quot;data_source&quot; module attribute</span>
<span class="n">data_source</span> <span class="o">=</span> <span class="n">_DataSource</span>


<span class="k">def</span> <span class="nf">local_or_remote_function</span><span class="p">(</span><span class="n">remote_print_output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator maker so that a function gets run either locally or remotely</span>
<span class="sd">    depending on the state of remote_access.access_remotely.  This decorator</span>
<span class="sd">    maker takes an optional remote_print_output argument that will be</span>
<span class="sd">    be printed (locally) if the function is executed remotely,</span>

<span class="sd">    For functions that are decorated using this wrapper:</span>

<span class="sd">    Every path that may be generated locally but used remotely should be</span>
<span class="sd">    split with _split_path(). Conversely the functions that use</span>
<span class="sd">    the resultant path should re-join them with os.path.join. In the</span>
<span class="sd">    remote case the join will happen using the remote rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">the_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">access_remotely</span><span class="p">:</span>
                <span class="c1"># If accessing a remote archive, establish the connection (if</span>
                <span class="c1"># necessary)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">connection_is_established</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">establish_connection</span><span class="p">():</span>
                            <span class="k">raise</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">RemoteConnectionError</span><span class="p">(</span>
                                <span class="s2">&quot;Unable to establish connection for remote fetch.&quot;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
                        <span class="c1"># An EOF error can be raised if the python interpreter is being</span>
                        <span class="c1"># called in such a way that input cannot be received from the</span>
                        <span class="c1"># user (e.g. when the python interpreter is called from MATLAB)</span>
                        <span class="c1"># If that is the case (and remote access is enabled), then</span>
                        <span class="c1"># raise an import error</span>
                        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Unable to interactively get remote access &quot;</span>
                                          <span class="s2">&quot;info from user.&quot;</span><span class="p">)</span>
                <span class="c1"># Print the output, if specified</span>
                <span class="k">if</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">show_print_output</span> <span class="ow">and</span> <span class="n">remote_print_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">remote_print_output</span><span class="p">)</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="c1"># Execute the function remotely and return the result</span>
                <span class="k">return</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">execute_remotely</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">the_decorator</span>


<span class="k">def</span> <span class="nf">_split_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a tuple of the components for ``path``. Strip off the drive if</span>
<span class="sd">    it exists AND access is remote. This works correctly for the local OS</span>
<span class="sd">    (linux / windows).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">parts</span>
    <span class="k">if</span> <span class="n">remote_access</span><span class="o">.</span><span class="n">access_remotely</span> <span class="ow">and</span> <span class="n">path</span><span class="o">.</span><span class="n">drive</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">parts</span>


<span class="k">def</span> <span class="nf">_get_start_stop_dates</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">date</span><span class="p">,</span>
                <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">date</span><span class="p">}</span>


<span class="c1"># Context dictionary to provide context for msid_files</span>
<span class="n">ft</span> <span class="o">=</span> <span class="n">pyyaks</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">ContextDict</span><span class="p">(</span><span class="s1">&#39;ft&#39;</span><span class="p">)</span>

<span class="c1"># Global (eng_archive) definition of file names</span>
<span class="n">msid_files</span> <span class="o">=</span> <span class="n">pyyaks</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">ContextDict</span><span class="p">(</span><span class="s1">&#39;msid_files&#39;</span><span class="p">,</span> <span class="n">basedir</span><span class="o">=</span><span class="n">ENG_ARCHIVE</span><span class="p">)</span>
<span class="n">msid_files</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">file_defs</span><span class="o">.</span><span class="n">msid_files</span><span class="p">)</span>

<span class="c1"># Module-level values defining available content types and column (MSID) names.</span>
<span class="c1"># Then convert from astropy Table to recarray for API stability.</span>
<span class="c1"># Note that filetypes.as_array().view(np.recarray) does not quite work...</span>
<span class="n">filetypes</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">DIR_PATH</span><span class="p">,</span> <span class="s1">&#39;filetypes.dat&#39;</span><span class="p">))</span>
<span class="n">filetypes_arr</span> <span class="o">=</span> <span class="n">filetypes</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
<span class="n">filetypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filetypes_arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">filetypes_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">filetypes</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">filetypes_arr</span>

<span class="c1"># Get the list of filenames (an array is built to pass all the filenames at</span>
<span class="c1"># once to the remote machine since passing them one at a time is rather slow)</span>
<span class="n">all_msid_names_files</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">filetype</span> <span class="ow">in</span> <span class="n">filetypes</span><span class="p">:</span>
    <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filetype</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">all_msid_names_files</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ft</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">])]</span> <span class="o">=</span> \
        <span class="n">_split_path</span><span class="p">(</span><span class="n">msid_files</span><span class="p">[</span><span class="s1">&#39;colnames&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">)</span>


<span class="c1"># Function to load MSID names from the files (executed remotely, if necessary)</span>
<span class="nd">@local_or_remote_function</span><span class="p">(</span><span class="s2">&quot;Loading MSID names from Ska eng archive server...&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load_msid_names</span><span class="p">(</span><span class="n">all_msid_names_files</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="n">all_colnames</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">msid_names_file</span> <span class="ow">in</span> <span class="n">all_msid_names_files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">all_colnames</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">msid_names_file</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">all_colnames</span>


<span class="k">def</span> <span class="nf">load_content</span><span class="p">(</span><span class="n">all_colnames</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Save the names</span>
    <span class="k">for</span> <span class="n">content_type</span><span class="p">,</span> <span class="n">msid_names</span> <span class="ow">in</span> <span class="n">all_colnames</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">content_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">msid_names</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">IGNORE_COLNAMES</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="c1"># Define MSID names as a dict of content_type: [MSID_names_for_content_type].</span>
<span class="c1"># This is a LazyDict so nothing happens until a value is requested.</span>
<span class="n">all_colnames</span> <span class="o">=</span> <span class="n">LazyDict</span><span class="p">(</span><span class="n">load_msid_names</span><span class="p">,</span> <span class="n">all_msid_names_files</span><span class="p">)</span>

<span class="c1"># Define MSID content definition as dict of MSID_name: content_type</span>
<span class="n">content</span> <span class="o">=</span> <span class="n">LazyDict</span><span class="p">(</span><span class="n">load_content</span><span class="p">,</span> <span class="n">all_colnames</span><span class="p">)</span>


<span class="c1"># Cache of the most-recently used TIME array and associated bad values mask.</span>
<span class="c1"># The key is (content_type, tstart, tstop).</span>
<span class="n">times_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>


<span class="c1"># Set up logging.</span>
<span class="k">class</span> <span class="nc">NullHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Handler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;Ska.engarchive.fetch&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">NullHandler</span><span class="p">())</span>
<span class="n">logger</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="get_units"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.get_units">[docs]</a><span class="k">def</span> <span class="nf">get_units</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Get the unit system currently being used for conversions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">UNITS</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="set_units"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.set_units">[docs]</a><span class="k">def</span> <span class="nf">set_units</span><span class="p">(</span><span class="n">unit_system</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the unit system used for output telemetry values.  The default</span>
<span class="sd">    is &quot;cxc&quot;.  Allowed values for ``unit_system``  are:</span>

<span class="sd">    ====  ==============================================================</span>
<span class="sd">    cxc   FITS standard units used in CXC archive files (basically MKS)</span>
<span class="sd">    sci   Same as &quot;cxc&quot; but with temperatures in degC instead of Kelvins</span>
<span class="sd">    eng   OCC engineering units (TDB P009, e.g. degF, ft-lb-sec, PSI)</span>
<span class="sd">    ====  ==============================================================</span>

<span class="sd">    :param unit_system: system of units (cxc, sci, eng)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">UNITS</span><span class="o">.</span><span class="n">set_units</span><span class="p">(</span><span class="n">unit_system</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_bad_times"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.read_bad_times">[docs]</a><span class="k">def</span> <span class="nf">read_bad_times</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Include a list of bad times from ``table`` in the fetch module</span>
<span class="sd">    ``bad_times`` registry.  This routine can be called multiple times with</span>
<span class="sd">    different tables and the bad times will be appended to the registry.  The</span>
<span class="sd">    table can include any number of bad time interval specifications, one per</span>
<span class="sd">    line.  A bad time interval line has three columns separated by whitespace,</span>
<span class="sd">    e.g.::</span>

<span class="sd">      aogbias1  2008:292:00:00:00  2008:297:00:00:00</span>

<span class="sd">    The MSID name is not case sensitive and the time values can be in any</span>
<span class="sd">    ``DateTime`` format.  Blank lines and any line starting with the #</span>
<span class="sd">    character are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bad_times</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;no_header&#39;</span><span class="p">,</span>
                           <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">bad_times</span><span class="p">:</span>
        <span class="n">msid_bad_times</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span></div>


<span class="c1"># Set up bad times dict</span>
<span class="n">msid_bad_times</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">read_bad_times</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">DIR_PATH</span><span class="p">,</span> <span class="s1">&#39;msid_bad_times.dat&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="msid_glob"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.msid_glob">[docs]</a><span class="k">def</span> <span class="nf">msid_glob</span><span class="p">(</span><span class="n">msid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the archive MSIDs matching ``msid``.</span>

<span class="sd">    The function returns a tuple of (msids, MSIDs) where ``msids`` is a list of</span>
<span class="sd">    MSIDs that is all lower case and (where possible) matches the input</span>
<span class="sd">    ``msid``.  The output ``MSIDs`` is all upper case and corresponds to the</span>
<span class="sd">    exact MSID names stored in the archive HDF5 files.</span>

<span class="sd">    :param msid: input MSID glob</span>
<span class="sd">    :returns: tuple (msids, MSIDs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msids</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">MSIDS</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="c1"># First check if `msid` matches a computed class.  This does not allow</span>
    <span class="c1"># for globs, and here the output MSIDs is the single computed class.</span>
    <span class="k">if</span> <span class="n">ComputedMsid</span><span class="o">.</span><span class="n">get_matching_comp_cls</span><span class="p">(</span><span class="n">msid</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">msid</span><span class="p">],</span> <span class="p">[</span><span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>

    <span class="n">sources</span> <span class="o">=</span> <span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">(</span><span class="n">include_test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
        <span class="n">ms</span><span class="p">,</span> <span class="n">MS</span> <span class="o">=</span> <span class="n">_msid_glob</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="n">msids</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">)</span>
        <span class="n">MSIDS</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">MS</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">msids</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MSID </span><span class="si">{!r}</span><span class="s1"> is not in </span><span class="si">{}</span><span class="s1"> data source(s)&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="s1">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">)))</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">msids</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">MSIDS</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_msid_glob</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the archive MSIDs matching ``msid``.</span>

<span class="sd">    The function returns a tuple of (msids, MSIDs) where ``msids`` is a list of</span>
<span class="sd">    MSIDs that is all lower case and (where possible) matches the input</span>
<span class="sd">    ``msid``.  The output ``MSIDs`` is all upper case and corresponds to the</span>
<span class="sd">    exact MSID names stored in the archive HDF5 files.</span>

<span class="sd">    :param msid: input MSID glob</span>
<span class="sd">    :returns: tuple (msids, MSIDs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_msids</span> <span class="o">=</span> <span class="n">data_source</span><span class="o">.</span><span class="n">get_msids</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="n">MSID</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="c1"># First try MSID or DP_&lt;MSID&gt;.  If success then return the upper</span>
    <span class="c1"># case version and whatever the user supplied (could be any case).</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="p">(</span><span class="n">MSID</span><span class="p">,</span> <span class="s1">&#39;DP_&#39;</span> <span class="o">+</span> <span class="n">MSID</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">source_msids</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">msid</span><span class="p">],</span> <span class="p">[</span><span class="n">match</span><span class="p">]</span>

    <span class="c1"># Next try as a file glob.  If there is a match then return a</span>
    <span class="c1"># list of matches, all lower case and all upper case.  Since the</span>
    <span class="c1"># input was a glob the returned msids are just lower case versions</span>
    <span class="c1"># of the matched upper case MSIDs.</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="p">(</span><span class="n">MSID</span><span class="p">,</span> <span class="s1">&#39;DP_&#39;</span> <span class="o">+</span> <span class="n">MSID</span><span class="p">):</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">source_msids</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_GLOB_MATCHES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;MSID spec </span><span class="si">{}</span><span class="s1"> matches more than </span><span class="si">{}</span><span class="s1"> MSIDs.  &#39;</span>
                    <span class="s1">&#39;Refine the spec or increase fetch.MAX_GLOB_MATCHES&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">MAX_GLOB_MATCHES</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">],</span> <span class="n">matches</span>

    <span class="c1"># msid not found for this data source</span>
    <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">_get_table_intervals_as_list</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">check_overlaps</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine if the input ``table`` looks like a table of intervals.  This can either be</span>
<span class="sd">    a structured array / Table with datestart / datestop or tstart / tstop columns,</span>
<span class="sd">    OR a list of lists.</span>

<span class="sd">    If so, return a list of corresponding start/stop tuples, otherwise return None.</span>

<span class="sd">    If ``check_overlaps`` is True then a check is made to assure that the supplied</span>
<span class="sd">    intervals do not overlap.  This is needed when reading multiple intervals with</span>
<span class="sd">    a single call to fetch, but not for bad times filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">secs</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">secs</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;start&#39;</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;stop&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">start</span><span class="p">])</span><span class="o">.</span><span class="n">secs</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">stop</span><span class="p">])</span><span class="o">.</span><span class="n">secs</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># Got an intervals list, now sort</span>
    <span class="k">if</span> <span class="n">check_overlaps</span> <span class="ow">and</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Check for overlaps</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input intervals overlap&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">intervals</span>


<div class="viewcode-block" id="MSID"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID">[docs]</a><span class="k">class</span> <span class="nc">MSID</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fetch data from the engineering telemetry archive into an MSID object.</span>

<span class="sd">    The input ``msid`` is case-insensitive and can include linux file &quot;glob&quot;</span>
<span class="sd">    patterns, for instance ``orb*1*_x`` (ORBITEPHEM1_X) or ``*pcadmd``</span>
<span class="sd">    (AOPCADMD).  For derived parameters the initial ``DP_`` is optional, for</span>
<span class="sd">    instance ``dpa_pow*`` (DP_DPA_POWER).</span>

<span class="sd">    :param msid: name of MSID (case-insensitive)</span>
<span class="sd">    :param start: start date of telemetry (Chandra.Time compatible)</span>
<span class="sd">    :param stop: stop date of telemetry (current time if not supplied)</span>
<span class="sd">    :param filter_bad: automatically filter out bad values</span>
<span class="sd">    :param stat: return 5-minute or daily statistics (&#39;5min&#39; or &#39;daily&#39;)</span>

<span class="sd">    :returns: MSID instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">units</span> <span class="o">=</span> <span class="n">UNITS</span>
    <span class="n">fetch</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">LAUNCH_DATE</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">msids</span><span class="p">,</span> <span class="n">MSIDs</span> <span class="o">=</span> <span class="n">msid_glob</span><span class="p">(</span><span class="n">msid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MSIDs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Multiple matches for </span><span class="si">{}</span><span class="s1"> in Eng Archive&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msid</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msid</span> <span class="o">=</span> <span class="n">msids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span> <span class="o">=</span> <span class="n">MSIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Capture the current module units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">Units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">get_msid_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span>
        <span class="k">if</span> <span class="n">stat</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;5min&#39;</span><span class="p">:</span> <span class="mi">328</span><span class="p">,</span> <span class="s1">&#39;daily&#39;</span><span class="p">:</span> <span class="mi">86400</span><span class="p">}[</span><span class="n">stat</span><span class="p">]</span>

        <span class="c1"># If ``start`` is actually a table of intervals then fetch</span>
        <span class="c1"># each interval separately and concatenate the results</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">_get_table_intervals_as_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">check_overlaps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">=</span> <span class="p">(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span> <span class="k">if</span> <span class="n">stop</span> <span class="k">else</span>
                      <span class="n">DateTime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;unix&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datestart</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestart</span> <span class="o">&lt;</span> <span class="n">DATE2000_LO</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span> <span class="o">&gt;</span> <span class="n">DATE2000_HI</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">datestart</span><span class="p">,</span> <span class="n">DATE2000_HI</span><span class="p">),</span>
                         <span class="p">(</span><span class="n">DATE2000_HI</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span><span class="p">)]</span>

        <span class="c1"># Get the times, values, bad values mask from the HDF5 files archive</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_over_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>

        <span class="c1"># If requested filter out bad values and set self.bad = None</span>
        <span class="k">if</span> <span class="n">filter_bad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestart</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">),</span>
                          <span class="p">(</span><span class="s1">&#39;stat&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">_get_data_over_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetch intervals separately and concatenate the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="n">msids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">))</span>

        <span class="c1"># No bad values column for stat=&#39;5min&#39; or &#39;daily&#39;, but still need this attribute.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span> <span class="o">=</span> <span class="n">msids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">])</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get data from the Eng archive&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Getting data for </span><span class="si">%s</span><span class="s1"> between </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span><span class="p">)</span>

        <span class="n">comp_cls</span> <span class="o">=</span> <span class="n">ComputedMsid</span><span class="o">.</span><span class="n">get_matching_comp_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp_cls</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_comp_data</span><span class="p">(</span><span class="n">comp_cls</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Avoid stomping on caller&#39;s filetype &#39;ft&#39; values with _cache_ft()</span>
        <span class="k">with</span> <span class="n">_cache_ft</span><span class="p">():</span>
            <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">content</span>
            <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span>

            <span class="k">with</span> <span class="n">_set_msid_files_basedir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datestart</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;maude&#39;</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MAUDE data source does not support telemetry statistics&#39;</span><span class="p">)</span>
                    <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_stat_data</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vals&#39;</span><span class="p">,</span> <span class="s1">&#39;times&#39;</span><span class="p">,</span> <span class="s1">&#39;bads&#39;</span><span class="p">]</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;cxc&#39;</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span> <span class="ow">and</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">get_msids</span><span class="p">(</span><span class="s1">&#39;cxc&#39;</span><span class="p">)):</span>
                        <span class="c1"># CACHE is normally True only when doing ingest processing.  Note</span>
                        <span class="c1"># also that to support caching the get_msid_data_from_cxc_cached</span>
                        <span class="c1"># method must be static.</span>
                        <span class="n">get_msid_data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_msid_data_from_cxc_cached</span> <span class="k">if</span> <span class="n">CACHE</span>
                                         <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_msid_data_from_cxc</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="n">get_msid_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;cxc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_start_stop_dates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>

                    <span class="k">if</span> <span class="s1">&#39;test-drop-half&#39;</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;vals&#39;</span><span class="p">):</span>
                        <span class="c1"># For testing purposes drop half the data off the end.  This assumes another</span>
                        <span class="c1"># data_source like &#39;cxc&#39; has been selected.</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bads</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
                        <span class="c1"># Following assumes only one prior data source but ok for controlled testing</span>
                        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_start_stop_dates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>

                    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;maude&#39;</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span> <span class="ow">and</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">get_msids</span><span class="p">(</span><span class="s1">&#39;maude&#39;</span><span class="p">)):</span>
                        <span class="c1"># Update self.vals, times, bads in place.  This might concatenate MAUDE</span>
                        <span class="c1"># telemetry to existing CXC values.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_get_msid_data_from_maude</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_comp_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp_cls</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Getting computed values for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Do computation.  This returns a dict of MSID attribute values.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">comp_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">])(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">)</span>

        <span class="c1"># Allow upstream class to be a bit sloppy on times and include samples</span>
        <span class="c1"># outside the time range.  This can happen with classes that inherit</span>
        <span class="c1"># from DerivedParameter.</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span>
        <span class="n">all_ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ok</span><span class="p">)</span>

        <span class="c1"># List of &quot;colnames&quot;, which is the ndarray attributes.  There can be</span>
        <span class="c1"># non-ndarray attributes that get returned, including typically &#39;unit&#39;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                         <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                             <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]))]</span>

        <span class="c1"># Apply attributes to self</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">all_ok</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">])):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_stat_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the actual work of getting stats values for an MSID from HDF5</span>
<span class="sd">        files&quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">msid_files</span><span class="p">[</span><span class="s1">&#39;stats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Opening </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="nd">@local_or_remote_function</span><span class="p">(</span><span class="s2">&quot;Getting stat data for &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span> <span class="o">+</span>
                                  <span class="s2">&quot; from Ska eng archive server...&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_stat_data_from_server</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">tables</span>
            <span class="n">open_file</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="s1">&#39;open_file&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span>
            <span class="n">h5</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">data</span>
            <span class="n">times</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="n">row0</span><span class="p">,</span> <span class="n">row1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">])</span>
            <span class="n">table_rows</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">]</span>  <span class="c1"># returns np.ndarray (structured array)</span>
            <span class="n">h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">],</span> <span class="n">table_rows</span><span class="p">,</span> <span class="n">row0</span><span class="p">,</span> <span class="n">row1</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">table_rows</span><span class="p">,</span> <span class="n">row0</span><span class="p">,</span> <span class="n">row1</span> <span class="o">=</span> \
            <span class="n">get_stat_data_from_server</span><span class="p">(</span><span class="n">_split_path</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Closed </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">table_rows</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="c1"># Don&#39;t like the way columns were named in the stats tables.</span>
            <span class="c1"># Fix that here.</span>
            <span class="n">colname_out</span> <span class="o">=</span> <span class="n">_plural</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span> <span class="k">if</span> <span class="n">colname</span> <span class="o">!=</span> <span class="s1">&#39;n&#39;</span> <span class="k">else</span> <span class="s1">&#39;samples&#39;</span>

            <span class="k">if</span> <span class="n">colname_out</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;vals&#39;</span><span class="p">,</span> <span class="s1">&#39;mins&#39;</span><span class="p">,</span> <span class="s1">&#39;maxes&#39;</span><span class="p">,</span> <span class="s1">&#39;means&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;p01s&#39;</span><span class="p">,</span> <span class="s1">&#39;p05s&#39;</span><span class="p">,</span> <span class="s1">&#39;p16s&#39;</span><span class="p">,</span> <span class="s1">&#39;p50s&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;p84s&#39;</span><span class="p">,</span> <span class="s1">&#39;p95s&#39;</span><span class="p">,</span> <span class="s1">&#39;p99s&#39;</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">,</span> <span class="n">table_rows</span><span class="p">[</span><span class="n">colname</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">colname_out</span> <span class="o">==</span> <span class="s1">&#39;stds&#39;</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">,</span> <span class="n">table_rows</span><span class="p">[</span><span class="n">colname</span><span class="p">],</span>
                                          <span class="n">delta_val</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">table_rows</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname_out</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colname_out</span><span class="p">)</span>

        <span class="c1"># Redefine the &#39;vals&#39; attribute to be &#39;means&#39; if it exists.  This is a</span>
        <span class="c1"># more consistent use of the &#39;vals&#39; attribute and there is little use</span>
        <span class="c1"># for the original sampled version.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;means&#39;</span><span class="p">):</span>
            <span class="c1"># Create new attribute midvals and add as a column (fixes kadi#17)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;midvals&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span>

        <span class="c1"># Convert vals to unicode for Python 3+.  If this MSID is a</span>
        <span class="c1"># state-valued MSID (with string value) then `vals` is the only possible</span>
        <span class="c1"># string attribute.  None of the others like mins/maxes etc will exist.</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@cache</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_msid_data_from_cxc_cached</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">unit_system</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the actual work of getting time and values for an MSID from HDF5</span>
<span class="sd">        files and cache recent results.  Caching is very beneficial for derived</span>
<span class="sd">        parameter updates but not desirable for normal fetch usage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MSID</span><span class="o">.</span><span class="n">_get_msid_data_from_cxc</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">unit_system</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_msid_data_from_cxc</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">unit_system</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the actual work of getting time and values for an MSID from HDF5</span>
<span class="sd">        files&quot;&quot;&quot;</span>

        <span class="c1"># Get a row slice into HDF5 file for this content type that picks out</span>
        <span class="c1"># the required time range plus a little padding on each end.</span>
        <span class="n">h5_slice</span> <span class="o">=</span> <span class="n">get_interval</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>

        <span class="c1"># Cache the last set of TIME values so repeated queries from within a</span>
        <span class="c1"># content type use the already-available times. Use the content, start</span>
        <span class="c1"># row and stop row as key. This guarantees that the times array matches</span>
        <span class="c1"># the subsequent values.</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">h5_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">h5_slice</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

        <span class="c1"># Read the TIME values either from cache or from disk.</span>
        <span class="k">if</span> <span class="n">times_cache</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cache_key</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using times_cache for </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times_cache</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>  <span class="c1"># Already filtered on times_ok</span>
            <span class="n">times_ok</span> <span class="o">=</span> <span class="n">times_cache</span><span class="p">[</span><span class="s1">&#39;ok&#39;</span><span class="p">]</span>  <span class="c1"># For filtering MSID.val and MSID.bad</span>
            <span class="n">times_all_ok</span> <span class="o">=</span> <span class="n">times_cache</span><span class="p">[</span><span class="s1">&#39;all_ok&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">msid_files</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

            <span class="nd">@local_or_remote_function</span><span class="p">(</span><span class="s2">&quot;Getting time data from Ska eng archive server...&quot;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">get_time_data_from_server</span><span class="p">(</span><span class="n">h5_slice</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">tables</span>
                <span class="n">open_file</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="s1">&#39;open_file&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span>
                <span class="n">h5</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">filename</span><span class="p">))</span>
                <span class="n">times_ok</span> <span class="o">=</span> <span class="o">~</span><span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">quality</span><span class="p">[</span><span class="n">h5_slice</span><span class="p">]</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">h5_slice</span><span class="p">]</span>
                <span class="n">h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span><span class="p">(</span><span class="n">times_ok</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>

            <span class="n">times_ok</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">get_time_data_from_server</span><span class="p">(</span><span class="n">h5_slice</span><span class="p">,</span> <span class="n">_split_path</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

            <span class="c1"># Filter bad times.  Last instance of bad times in archive is 2004</span>
            <span class="c1"># so don&#39;t do this unless needed.  Creating a new &#39;times&#39; array is</span>
            <span class="c1"># much more expensive than checking for np.all(times_ok).</span>
            <span class="n">times_all_ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">times_ok</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">times_all_ok</span><span class="p">:</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">times_ok</span><span class="p">]</span>

            <span class="n">times_cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cache_key</span><span class="p">,</span>
                                    <span class="n">val</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
                                    <span class="n">ok</span><span class="o">=</span><span class="n">times_ok</span><span class="p">,</span>
                                    <span class="n">all_ok</span><span class="o">=</span><span class="n">times_all_ok</span><span class="p">))</span>

        <span class="c1"># Extract the actual MSID values and bad values mask</span>
        <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msid</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">msid_files</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="nd">@local_or_remote_function</span><span class="p">(</span><span class="s2">&quot;Getting msid data for &quot;</span> <span class="o">+</span> <span class="n">msid</span> <span class="o">+</span>
                                  <span class="s2">&quot; from Ska eng archive server...&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_msid_data_from_server</span><span class="p">(</span><span class="n">h5_slice</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">tables</span>
            <span class="n">open_file</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="s1">&#39;open_file&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span>
            <span class="n">h5</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">h5_slice</span><span class="p">]</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">quality</span><span class="p">[</span><span class="n">h5_slice</span><span class="p">]</span>
            <span class="n">h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">bads</span><span class="p">)</span>

        <span class="n">vals</span><span class="p">,</span> <span class="n">bads</span> <span class="o">=</span> <span class="n">get_msid_data_from_server</span><span class="p">(</span><span class="n">h5_slice</span><span class="p">,</span> <span class="n">_split_path</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

        <span class="c1"># Remote access will return arrays that don&#39;t own their data, see #150.</span>
        <span class="c1"># For an explanation see:</span>
        <span class="c1"># https://ipyparallel.readthedocs.io/en/latest/details.html#non-copying-sends-and-numpy-arrays</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bads</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">vals</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="n">bads</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Filter bad times rows if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">times_all_ok</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Filtering bad times values for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">msid</span><span class="p">)</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="n">bads</span><span class="p">[</span><span class="n">times_ok</span><span class="p">]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">times_ok</span><span class="p">]</span>

        <span class="c1"># Slice down to exact requested time range</span>
        <span class="n">row0</span><span class="p">,</span> <span class="n">row1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">[</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Slicing </span><span class="si">%s</span><span class="s1"> arrays [</span><span class="si">%d</span><span class="s1">:</span><span class="si">%d</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">row0</span><span class="p">,</span> <span class="n">row1</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">Units</span><span class="p">(</span><span class="n">unit_system</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">vals</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">])</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">]</span>
        <span class="n">bads</span> <span class="o">=</span> <span class="n">bads</span><span class="p">[</span><span class="n">row0</span><span class="p">:</span><span class="n">row1</span><span class="p">]</span>

        <span class="c1"># Possibly expand the bads list for a set of about 30 MSIDs which</span>
        <span class="c1"># have incorrect values in CXCDS telemetry</span>
        <span class="n">bads</span> <span class="o">=</span> <span class="n">_fix_ctu_dwell_mode_bads</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">bads</span><span class="p">)</span>

        <span class="c1"># Change bytestring to (unicode) string</span>
        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">bads</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_msid_data_from_maude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">unit_system</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get time and values for an MSID from MAUDE.</span>
<span class="sd">        Returned values are (for now) all assumed to be good.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">maude</span>

        <span class="c1"># Telemetry values from another data_source may already be available.  If</span>
        <span class="c1"># so then only query MAUDE from after the last available point.</span>
        <span class="n">telem_already</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;times&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">telem_already</span><span class="p">:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.001</span>  <span class="c1"># Don&#39;t fetch the last point again</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tstop</span> <span class="o">-</span> <span class="n">tstart</span> <span class="o">&lt;</span> <span class="n">dt</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Already got enough data from the original query, no need to hit MAUDE</span>
                <span class="k">return</span>

        <span class="c1"># Actually query MAUDE</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">data_source</span><span class="o">.</span><span class="n">options</span><span class="p">()[</span><span class="s1">&#39;maude&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">maude</span><span class="o">.</span><span class="n">get_msids</span><span class="p">(</span><span class="n">msids</span><span class="o">=</span><span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;MAUDE query failed: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

        <span class="c1"># Only one MSID is queried from MAUDE but maude.get_msids() already returns</span>
        <span class="c1"># a list of results, so select the first element.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="n">Units</span><span class="p">(</span><span class="n">unit_system</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">],</span> <span class="n">from_system</span><span class="o">=</span><span class="s1">&#39;eng&#39;</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span>
        <span class="n">bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># No &#39;bad&#39; values from MAUDE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;maude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_start_stop_dates</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;maude&#39;</span><span class="p">][</span><span class="s1">&#39;flags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;flags&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">telem_already</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">vals</span><span class="p">])</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">times</span><span class="p">])</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bads</span><span class="p">,</span> <span class="n">bads</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="n">bads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of state codes tuples (raw_count, state_code) for state-valued</span>
<span class="sd">        MSIDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_codes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span> <span class="ow">in</span> <span class="n">STATE_CODES</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_codes</span> <span class="o">=</span> <span class="n">STATE_CODES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_state_codes&#39;</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">Ska.tdb</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">states</span> <span class="o">=</span> <span class="n">Ska</span><span class="o">.</span><span class="n">tdb</span><span class="o">.</span><span class="n">msids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">]</span><span class="o">.</span><span class="n">Tsc</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state_codes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">states</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="s1">&#39;CALIBRATION_SET_NUM&#39;</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;MSID </span><span class="si">{}</span><span class="s1"> has string vals but no state codes &#39;</span>
                                  <span class="s1">&#39;or multiple calibration sets&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state_codes</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;LOW_RAW_COUNT&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state_codes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;LOW_RAW_COUNT&#39;</span><span class="p">],</span>
                                          <span class="n">state</span><span class="p">[</span><span class="s1">&#39;STATE_CODE&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_codes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raw counts corresponding to the string state-code values that are</span>
<span class="sd">        stored in ``self.vals``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is not a string-type value then there are no raw values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_codes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_vals</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_raw_vals&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># CXC state code telem all has same length with trailing spaces</span>
            <span class="c1"># so find max length for formatting below.</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_codes</span><span class="p">)</span>
            <span class="n">fmtstr</span> <span class="o">=</span> <span class="s1">&#39;{:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s}&#39;</span>
            <span class="k">for</span> <span class="n">raw_val</span><span class="p">,</span> <span class="n">state_code</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_codes</span><span class="p">:</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">==</span> <span class="n">fmtstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state_code</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raw_vals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_val</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_vals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tdb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access the Telemetry database entries for this MSID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">Ska.tdb</span>
        <span class="k">return</span> <span class="n">Ska</span><span class="o">.</span><span class="n">tdb</span><span class="o">.</span><span class="n">msids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">]</span>

<div class="viewcode-block" id="MSID.interpolate"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform nearest-neighbor interpolation of the MSID to the specified</span>
<span class="sd">        time sequence.</span>

<span class="sd">        The time sequence steps uniformly by ``dt`` seconds starting at the</span>
<span class="sd">        ``start`` time and ending at the ``stop`` time.  If not provided the</span>
<span class="sd">        times default to the first and last times for the MSID.</span>

<span class="sd">        The MSID ``times`` attribute is set to the common time sequence.  In</span>
<span class="sd">        addition a new attribute ``times0`` is defined that stores the nearest</span>
<span class="sd">        neighbor interpolated time, providing the *original* timestamps of each</span>
<span class="sd">        new interpolated value for that MSID.</span>

<span class="sd">        If ``times`` is provided then this gets used instead of the default linear</span>
<span class="sd">        progression from ``start`` and ``dt``.</span>

<span class="sd">        :param dt: time step (sec, default=328.0)</span>
<span class="sd">        :param start: start of interpolation period (DateTime format)</span>
<span class="sd">        :param stop: end of interpolation period (DateTime format)</span>
<span class="sd">        :param times: array of times for interpolation (default=None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">Ska.Numpy</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">kwarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If &quot;times&quot; keyword is set then &quot;dt&quot;, &quot;start&quot;, &#39;</span>
                                 <span class="s1">&#39;and &quot;stop&quot; cannot be set&#39;</span><span class="p">)</span>
            <span class="c1"># Use user-supplied times that are within the range of telemetry.</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">times</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="mf">328.0</span> <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dt</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span> <span class="k">if</span> <span class="n">start</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span> <span class="k">if</span> <span class="n">stop</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Legacy method for backward compatibility.  Note that the np.arange()</span>
            <span class="c1"># call accrues floating point error.</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Interpolating index for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msid</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">Ska</span><span class="o">.</span><span class="n">Numpy</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Slicing on indexes&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">colvals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">colvals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="n">colvals</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>

        <span class="c1"># Make a new attribute times0 that stores the nearest neighbor</span>
        <span class="c1"># interpolated times.  Then set the MSID times to be the common</span>
        <span class="c1"># interpolation times.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span></div>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="MSID.filter_bad"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.filter_bad">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter out any bad values.</span>

<span class="sd">        After applying this method the &quot;bads&quot; column will be set to None to</span>
<span class="sd">        indicate that there are no bad values.</span>

<span class="sd">        :param bads: Bad values mask.  If not supplied then self.bads is used.</span>
<span class="sd">        :param copy: return a copy of MSID object with bad values filtered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="c1"># If bad mask is provided then override any existing bad mask for MSID</span>
        <span class="k">if</span> <span class="n">bads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="n">bads</span>

        <span class="c1"># Nothing to do if bads is None (i.e. bad values already filtered)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">bads</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Filtering bad values for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">msid</span><span class="p">)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="o">~</span><span class="n">obj</span><span class="o">.</span><span class="n">bads</span>
            <span class="n">colnames</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">colnames</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;bads&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">colname</span><span class="p">)[</span><span class="n">ok</span><span class="p">])</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="MSID.filter_bad_times"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.filter_bad_times">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bad_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter out intervals of bad data in the MSID object.</span>

<span class="sd">        There are three usage options:</span>

<span class="sd">        - Supply no arguments.  This will use the global list of bad times read</span>
<span class="sd">          in with fetch.read_bad_times().</span>
<span class="sd">        - Supply both ``start`` and ``stop`` values where each is a single</span>
<span class="sd">          value in a valid DateTime format.</span>
<span class="sd">        - Supply an ``table`` parameter in the form of a 2-column table of</span>
<span class="sd">          start and stop dates (space-delimited) or the name of a file with</span>
<span class="sd">          data in the same format.</span>

<span class="sd">        The ``table`` parameter must be supplied as a table or the name of a</span>
<span class="sd">        table file, for example::</span>

<span class="sd">          bad_times = [&#39;2008:292:00:00:00 2008:297:00:00:00&#39;,</span>
<span class="sd">                       &#39;2008:305:00:12:00 2008:305:00:12:03&#39;,</span>
<span class="sd">                       &#39;2010:101:00:01:12 2010:101:00:01:25&#39;]</span>
<span class="sd">          msid.filter_bad_times(table=bad_times)</span>
<span class="sd">          msid.filter_bad_times(table=&#39;msid_bad_times.dat&#39;)</span>

<span class="sd">        :param start: Start of time interval to exclude (any DateTime format)</span>
<span class="sd">        :param stop: End of time interval to exclude (any DateTime format)</span>
<span class="sd">        :param table: Two-column table (start, stop) of bad time intervals</span>
<span class="sd">        :param copy: return a copy of MSID object with bad times filtered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bad_times</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;no_header&#39;</span><span class="p">,</span>
                                   <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bad_times</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">msid_glob</span><span class="p">,</span> <span class="n">times</span> <span class="ow">in</span> <span class="n">msid_bad_times</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">,</span> <span class="n">msid_glob</span><span class="p">):</span>
                    <span class="n">bad_times</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;filter_times requires either 2 args &#39;</span>
                             <span class="s1">&#39;(start, stop) or no args&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bad_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)]</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_filter_times</span><span class="p">(</span><span class="n">bad_times</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="MSID.remove_intervals"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.remove_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">remove_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove telemetry points that occur within the specified ``intervals``</span>

<span class="sd">        This method is the converse of select_intervals().</span>

<span class="sd">        The ``intervals`` argument can be either a list of (start, stop) tuples</span>
<span class="sd">        or an EventQuery object from kadi.</span>

<span class="sd">        If ``copy`` is set to True then a copy of the MSID object is made prior</span>
<span class="sd">        to removing intervals, and that copy is returned.  The default is to</span>
<span class="sd">        remove intervals in place.</span>

<span class="sd">        This example shows fetching the pitch component of the spacecraft rate.</span>
<span class="sd">        After examining the rates, the samples during maneuvers are then removed</span>
<span class="sd">        and the standard deviation is recomputed.  This filters out the large</span>
<span class="sd">        rates during maneuvers::</span>

<span class="sd">          &gt;&gt;&gt; aorate2 = fetch.Msid(&#39;aorate2&#39;, &#39;2011:001&#39;, &#39;2011:002&#39;)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.vals.mean() * 3600 * 180 / np.pi  # rate in arcsec/sec</span>
<span class="sd">          3.9969393528801782</span>
<span class="sd">          &gt;&gt;&gt; figure(1)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.plot(&#39;,&#39;)</span>

<span class="sd">          &gt;&gt;&gt; from kadi import events</span>
<span class="sd">          &gt;&gt;&gt; aorate2.remove_intervals(events.manvrs)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.vals.mean() * 3600 * 180 / np.pi  # rate in arcsec/sec</span>
<span class="sd">          -0.0003688639491030978</span>
<span class="sd">          &gt;&gt;&gt; figure(2)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.plot(&#39;,&#39;)</span>

<span class="sd">        :param intervals: EventQuery or iterable (N x 2) with start, stop dates/times</span>
<span class="sd">        :param copy: return a copy of MSID object with intervals removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_filter_times</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="MSID.select_intervals"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.select_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">select_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select telemetry points that occur within the specified ``intervals``</span>

<span class="sd">        This method is the converse of remove_intervals().</span>

<span class="sd">        The ``intervals`` argument can be either a list of (start, stop) tuples</span>
<span class="sd">        or an EventQuery object from kadi.</span>

<span class="sd">        If ``copy`` is set to True then a copy of the MSID object is made prior</span>
<span class="sd">        to selecting intervals, and that copy is returned.  The default is to</span>
<span class="sd">        selecte intervals in place.</span>

<span class="sd">        This example shows fetching the pitch component of the spacecraft rate.</span>
<span class="sd">        After examining the rates, the samples during maneuvers are then selected</span>
<span class="sd">        and the mean is recomputed.  This highlights the large rates during</span>
<span class="sd">        maneuvers::</span>

<span class="sd">          &gt;&gt;&gt; aorate2 = fetch.Msid(&#39;aorate2&#39;, &#39;2011:001&#39;, &#39;2011:002&#39;)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.vals.mean() * 3600 * 180 / np.pi  # rate in arcsec/sec</span>
<span class="sd">          3.9969393528801782</span>
<span class="sd">          &gt;&gt;&gt; figure(1)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.plot(&#39;,&#39;)</span>

<span class="sd">          &gt;&gt;&gt; from kadi import events</span>
<span class="sd">          &gt;&gt;&gt; aorate2.select_intervals(events.manvrs)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.vals.mean() * 3600 * 180 / np.pi  # rate in arcsec/sec</span>
<span class="sd">          24.764309542605481</span>
<span class="sd">          &gt;&gt;&gt; figure(2)</span>
<span class="sd">          &gt;&gt;&gt; aorate2.plot(&#39;,&#39;)</span>

<span class="sd">        :param intervals: EventQuery or iterable (N x 2) with start, stop dates/times</span>
<span class="sd">        :param copy: return a copy of MSID object with intervals selected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_filter_times</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">_filter_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the times of self based on ``intervals``.</span>

<span class="sd">        :param intervals: iterable (N x 2) with tstart, tstop in seconds</span>
<span class="sd">        :param exclude: exclude intervals if True, else include intervals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make an initial acceptance mask.  If exclude is True then initially</span>
        <span class="c1"># all values are allowed (ok=True).  If exclude is False (i.e. only</span>
        <span class="c1"># include the interval times) then ok=False everywhere.</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">ok</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">exclude</span>

        <span class="c1"># See if the input intervals is actually a table of intervals</span>
        <span class="n">intervals_list</span> <span class="o">=</span> <span class="n">_get_table_intervals_as_list</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">check_overlaps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intervals_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="n">intervals_list</span>

        <span class="c1"># Check if this is an EventQuery.  Would rather not import EventQuery</span>
        <span class="c1"># because this is expensive (django), so just look at the names in</span>
        <span class="c1"># object MRO.</span>
        <span class="k">if</span> <span class="s1">&#39;EventQuery&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">intervals</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">):</span>
            <span class="n">intervals</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">intervals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datestart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span><span class="p">)</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">tstop</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start time </span><span class="si">%s</span><span class="s2"> must be less than stop time </span><span class="si">%s</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">tstop</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">tstart</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Find the indexes of bad data.  Using side=left,right respectively</span>
            <span class="c1"># will exclude points exactly equal to the bad_times values</span>
            <span class="c1"># (though in reality an exact tie is extremely unlikely).</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">ok</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">exclude</span>

        <span class="n">colnames</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>

<div class="viewcode-block" id="MSID.write_zip"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.write_zip">[docs]</a>    <span class="k">def</span> <span class="nf">write_zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write MSID to a zip file named ``filename``</span>

<span class="sd">        Within the zip archive the data for this MSID will be stored in csv</span>
<span class="sd">        format with the name &lt;msid_name&gt;.csv.</span>

<span class="sd">        :param filename: output zipfile name</span>
<span class="sd">        :param append: append to an existing zipfile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">zipfile</span>

        <span class="n">colnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;bads&#39;</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
            <span class="n">colnames</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;bads&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_codes</span><span class="p">:</span>
            <span class="n">colnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;raw_vals&#39;</span><span class="p">)</span>

        <span class="c1"># Indexes value is not interesting for output</span>
        <span class="k">if</span> <span class="s1">&#39;indexes&#39;</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
            <span class="n">colnames</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;indexes&#39;</span><span class="p">)</span>

        <span class="n">colvals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="k">if</span> <span class="n">append</span>
                                       <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                                       <span class="k">else</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msid</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">external_attr</span> <span class="o">=</span> <span class="mo">0o664</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>  <span class="c1"># Set permissions</span>
        <span class="n">info</span><span class="o">.</span><span class="n">date_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()[:</span><span class="mi">7</span><span class="p">]</span>
        <span class="n">info</span><span class="o">.</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span>
        <span class="n">f</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
                   <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                   <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">colvals</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="MSID.logical_intervals"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.logical_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">logical_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">complete_intervals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine contiguous intervals during which the logical comparison</span>
<span class="sd">        expression &quot;MSID.vals op val&quot; is True.  Allowed values for ``op``</span>
<span class="sd">        are::</span>

<span class="sd">          ==  !=  &gt;  &lt;  &gt;=  &lt;=</span>

<span class="sd">        If ``complete_intervals`` is True (default) then the intervals are guaranteed to</span>
<span class="sd">        be complete so that the all reported intervals had a transition before and after</span>
<span class="sd">        within the telemetry interval.</span>

<span class="sd">        If ``max_gap`` is specified then any time gaps longer than ``max_gap`` are</span>
<span class="sd">        filled with a fictitious False value to create an artificial interval</span>
<span class="sd">        boundary at ``max_gap / 2`` seconds from the nearest data value.</span>

<span class="sd">        Returns a structured array table with a row for each interval.</span>
<span class="sd">        Columns are:</span>

<span class="sd">        * datestart: date of interval start</span>
<span class="sd">        * datestop: date of interval stop</span>
<span class="sd">        * duration: duration of interval (sec)</span>
<span class="sd">        * tstart: time of interval start (CXC sec)</span>
<span class="sd">        * tstop: time of interval stop (CXC sec)</span>

<span class="sd">        Examples::</span>

<span class="sd">          &gt;&gt;&gt; dat = fetch.MSID(&#39;aomanend&#39;, &#39;2010:001&#39;, &#39;2010:005&#39;)</span>
<span class="sd">          &gt;&gt;&gt; manvs = dat.logical_intervals(&#39;==&#39;, &#39;NEND&#39;)</span>

<span class="sd">          &gt;&gt;&gt; dat = fetch.MSID(&#39;61PSTS02&#39;, &#39;1999:200&#39;, &#39;2000:001&#39;)</span>
<span class="sd">          &gt;&gt;&gt; safe_suns = dat.logical_intervals(&#39;==&#39;, &#39;SSM&#39;, complete_intervals=False, max_gap=66)</span>

<span class="sd">        :param op: logical operator, one of ==  !=  &gt;  &lt;  &gt;=  &lt;=</span>
<span class="sd">        :param val: comparison value</span>
<span class="sd">        :param complete_intervals: return only complete intervals (default=True)</span>
<span class="sd">        :param max_gap: max allowed gap between time stamps (sec, default=None)</span>
<span class="sd">        :returns: structured array table of intervals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>

        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
               <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span>
               <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
               <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
               <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
               <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;op = &quot;</span><span class="si">{}</span><span class="s1">&quot; is not in allowed values: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

        <span class="c1"># Do local version of bad value filtering</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bads</span><span class="p">):</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">bads</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="n">bools</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">logical_intervals</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">bools</span><span class="p">,</span> <span class="n">complete_intervals</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSID.state_intervals"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.state_intervals">[docs]</a>    <span class="k">def</span> <span class="nf">state_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine contiguous intervals during which the MSID value</span>
<span class="sd">        is unchanged.</span>

<span class="sd">        Returns a structured array table with a row for each interval.</span>
<span class="sd">        Columns are:</span>

<span class="sd">        * datestart: date of interval start</span>
<span class="sd">        * datestop: date of interval stop</span>
<span class="sd">        * duration: duration of interval (sec)</span>
<span class="sd">        * tstart: time of interval start (CXC sec)</span>
<span class="sd">        * tstop: time of interval stop (CXC sec)</span>
<span class="sd">        * val: MSID value during the interval</span>

<span class="sd">        Example::</span>

<span class="sd">          dat = fetch.MSID(&#39;cobsrqid&#39;, &#39;2010:001&#39;, &#39;2010:005&#39;)</span>
<span class="sd">          obsids = dat.state_intervals()</span>

<span class="sd">        :param val: state value for which intervals are returned.</span>
<span class="sd">        :returns: structured array table of intervals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>

        <span class="c1"># Do local version of bad value filtering</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bads</span><span class="p">):</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">bads</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Filtered data length must be at least 2&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">state_intervals</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSID.iplot"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.iplot">[docs]</a>    <span class="k">def</span> <span class="nf">iplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;-b&#39;</span><span class="p">,</span> <span class="n">fmt_minmax</span><span class="o">=</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make an interactive plot for exploring the MSID data.</span>

<span class="sd">        This method opens a new plot figure (or clears the current figure) and</span>
<span class="sd">        plots the MSID ``vals`` versus ``times``.  This plot can be panned or</span>
<span class="sd">        zoomed arbitrarily and the data values will be fetched from the archive</span>
<span class="sd">        as needed.  Depending on the time scale, ``iplot`` displays either full</span>
<span class="sd">        resolution, 5-minute, or daily values.  For 5-minute and daily values</span>
<span class="sd">        the min and max values are also plotted.</span>

<span class="sd">        Once the plot is displayed and the window is selected by clicking in</span>
<span class="sd">        it, the following key commands are recognized::</span>

<span class="sd">          a: autoscale for full data range in x and y</span>
<span class="sd">          m: toggle plotting of min/max values</span>
<span class="sd">          p: pan at cursor x</span>
<span class="sd">          y: toggle autoscaling of y-axis</span>
<span class="sd">          z: zoom at cursor x</span>
<span class="sd">          ?: print help</span>

<span class="sd">        Example::</span>

<span class="sd">          dat = fetch.Msid(&#39;aoattqt1&#39;, &#39;2011:001&#39;, &#39;2012:001&#39;, stat=&#39;5min&#39;)</span>
<span class="sd">          dat.iplot()</span>
<span class="sd">          dat.iplot(&#39;.b&#39;, &#39;.c&#39;, markersize=0.5)</span>

<span class="sd">        Caveat: the ``iplot()`` method is not meant for use within scripts, and</span>
<span class="sd">        may give unexpected results if used in combination with other plotting</span>
<span class="sd">        commands directed at the same plot figure.</span>

<span class="sd">        :param fmt: plot format for values (default=&quot;-b&quot;)</span>
<span class="sd">        :param fmt_minmax: plot format for mins and maxes (default=&quot;-c&quot;)</span>
<span class="sd">        :param plot_kwargs: additional plotting keyword args</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.plot</span> <span class="kn">import</span> <span class="n">MsidPlot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iplot</span> <span class="o">=</span> <span class="n">MsidPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">fmt_minmax</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSID.plot"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSID.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the MSID ``vals`` using Ska.Matplotlib.plot_cxctime()</span>

<span class="sd">        This is a convenience function for plotting the MSID values.  It</span>
<span class="sd">        is equivalent to::</span>

<span class="sd">          plot_cxctime(self.times, self.vals, *args, **kwargs)</span>

<span class="sd">        where ``*args`` are additional arguments and ``**kwargs`` are</span>
<span class="sd">        additional keyword arguments that are accepted by ``plot_cxctime()``.</span>

<span class="sd">        Example::</span>

<span class="sd">          dat = fetch.Msid(&#39;tephin&#39;, &#39;2011:001&#39;, &#39;2012:001&#39;, stat=&#39;5min&#39;)</span>
<span class="sd">          dat.plot(&#39;-r&#39;, linewidth=2)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">Ska.Matplotlib</span> <span class="kn">import</span> <span class="n">plot_cxctime</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_vals</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_codes</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span>
        <span class="n">plot_cxctime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">state_codes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_codes</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MSIDset"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSIDset">[docs]</a><span class="k">class</span> <span class="nc">MSIDset</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fetch a set of MSIDs from the engineering telemetry archive.</span>

<span class="sd">    Each input ``msid`` is case-insensitive and can include linux file &quot;glob&quot;</span>
<span class="sd">    patterns, for instance ``orb*1*_?`` (ORBITEPHEM1_X, Y and Z) or</span>
<span class="sd">    ``aoattqt[1234]`` (AOATTQT1, 2, 3, and 4).  For derived parameters the</span>
<span class="sd">    initial ``DP_`` is optional, for instance ``dpa_pow*`` (DP_DPA_POWER).</span>

<span class="sd">    :param msids: list of MSID names (case-insensitive)</span>
<span class="sd">    :param start: start date of telemetry (Chandra.Time compatible)</span>
<span class="sd">    :param stop: stop date of telemetry (current time if not supplied)</span>
<span class="sd">    :param filter_bad: automatically filter out bad values</span>
<span class="sd">    :param stat: return 5-minute or daily statistics (&#39;5min&#39; or &#39;daily&#39;)</span>

<span class="sd">    :returns: Dict-like object containing MSID instances keyed by MSID name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MSID</span> <span class="o">=</span> <span class="n">MSID</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">LAUNCH_DATE</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MSIDset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="n">_get_table_intervals_as_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">check_overlaps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">=</span> <span class="p">(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span> <span class="k">if</span> <span class="n">stop</span> <span class="k">else</span> <span class="n">DateTime</span><span class="p">()</span><span class="o">.</span><span class="n">secs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datestart</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datestop</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span><span class="o">.</span><span class="n">date</span>

        <span class="c1"># Input ``msids`` may contain globs, so expand each and add to new list</span>
        <span class="n">new_msids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
            <span class="n">new_msids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">msid_glob</span><span class="p">(</span><span class="n">msid</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">new_msids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span>
                                       <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="n">stat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="n">stat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filter_bad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;tstart&#39;</span><span class="p">,</span> <span class="s1">&#39;tstop&#39;</span><span class="p">,</span> <span class="s1">&#39;datestart&#39;</span><span class="p">,</span> <span class="s1">&#39;datestop&#39;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="MSIDset.copy"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSIDset.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">()</span></div>

<div class="viewcode-block" id="MSIDset.filter_bad"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSIDset.filter_bad">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter bad values for the MSID set.</span>

<span class="sd">        This function applies the union (logical-OR) of bad value masks for all</span>
<span class="sd">        MSIDs in the set with the same content type.  The result is that the</span>
<span class="sd">        filtered MSID samples are valid for *all* MSIDs within the</span>
<span class="sd">        content type and the arrays all match up.</span>

<span class="sd">        For example::</span>

<span class="sd">          msids = fetch.MSIDset([&#39;aorate1&#39;, &#39;aorate2&#39;, &#39;aogyrct1&#39;, &#39;aogyrct2&#39;],</span>
<span class="sd">                                &#39;2009:001&#39;, &#39;2009:002&#39;)</span>
<span class="sd">          msids.filter_bad()</span>

<span class="sd">        Since ``aorate1`` and ``aorate2`` both have content type of</span>
<span class="sd">        ``pcad3eng`` they will be filtered as a group and will remain with the</span>
<span class="sd">        same sampling.  This will allow something like::</span>

<span class="sd">          plot(msids[&#39;aorate1&#39;].vals, msids[&#39;aorate2&#39;].vals)</span>

<span class="sd">        Likewise the two gyro count MSIDs would be filtered as a group.  If</span>
<span class="sd">        this group-filtering is not the desired behavior one can always call</span>
<span class="sd">        the individual MSID.filter_bad() function for each MSID in the set::</span>

<span class="sd">          for msid in msids.values():</span>
<span class="sd">              msid.filter_bad()</span>

<span class="sd">        :param copy: return a copy of MSID object with intervals selected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">content</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">content</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">msids</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                     <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">content</span> <span class="o">==</span> <span class="n">content</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bads</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">bads</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bads</span> <span class="o">|=</span> <span class="n">msid</span><span class="o">.</span><span class="n">bads</span>

            <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
                <span class="n">msid</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">(</span><span class="n">bads</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="MSIDset.filter_bad_times"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSIDset.filter_bad_times">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bad_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter out intervals of bad data in the MSIDset object.</span>

<span class="sd">        There are three usage options:</span>

<span class="sd">        - Supply no arguments.  This will use the global list of bad times read</span>
<span class="sd">          in with fetch.read_bad_times().</span>
<span class="sd">        - Supply both ``start`` and ``stop`` values where each is a single</span>
<span class="sd">          value in a valid DateTime format.</span>
<span class="sd">        - Supply an ``table`` parameter in the form of a 2-column table of</span>
<span class="sd">          start and stop dates (space-delimited) or the name of a file with</span>
<span class="sd">          data in the same format.</span>

<span class="sd">        The ``table`` parameter must be supplied as a table or the name of a</span>
<span class="sd">        table file, for example::</span>

<span class="sd">          msidset.filter_bad_times()</span>
<span class="sd">          bad_times = [&#39;2008:292:00:00:00 2008:297:00:00:00&#39;,</span>
<span class="sd">                       &#39;2008:305:00:12:00 2008:305:00:12:03&#39;,</span>
<span class="sd">                       &#39;2010:101:00:01:12 2010:101:00:01:25&#39;]</span>
<span class="sd">          msidset.filter_bad_times(table=bad_times)</span>
<span class="sd">          msidset.filter_bad_times(table=&#39;msid_bad_times.dat&#39;)</span>

<span class="sd">        :param start: Start of time interval to exclude (any DateTime format)</span>
<span class="sd">        :param stop: End of time interval to exclude (any DateTime format)</span>
<span class="sd">        :param table: Two-column table (start, stop) of bad time intervals</span>
<span class="sd">        :param copy: return a copy of MSID object with intervals selected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">msid</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="MSIDset.interpolate"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSIDset.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">bad_union</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform nearest-neighbor interpolation of all MSID values in the set</span>
<span class="sd">        to a common time sequence.  The values are updated in-place.</span>

<span class="sd">        **Times**</span>

<span class="sd">        The time sequence steps uniformly by ``dt`` seconds starting at the</span>
<span class="sd">        ``start`` time and ending at the ``stop`` time.  If not provided the</span>
<span class="sd">        times default to the ``start`` and ``stop`` times for the MSID set.</span>

<span class="sd">        If ``times`` is provided then this gets used instead of the default linear</span>
<span class="sd">        progression from ``start`` and ``dt``.</span>

<span class="sd">        For each MSID in the set the ``times`` attribute is set to the common</span>
<span class="sd">        time sequence.  In addition a new attribute ``times0`` is defined that</span>
<span class="sd">        stores the nearest neighbor interpolated time, providing the *original*</span>
<span class="sd">        timestamps of each new interpolated value for that MSID.</span>

<span class="sd">        **Filtering and bad values**</span>

<span class="sd">        If ``filter_bad`` is True (default) then bad values are filtered from</span>
<span class="sd">        the interpolated MSID set.  There are two strategies for doing this:</span>

<span class="sd">        1) ``bad_union = False``</span>

<span class="sd">           Remove the bad values in each MSID prior to interpolating the set to</span>
<span class="sd">           a common time series.  This essentially says to use all the available</span>
<span class="sd">           data individually.  Each MSID has bad data filtered individually</span>
<span class="sd">           *before* interpolation so that the nearest neighbor interpolation only</span>
<span class="sd">           finds good data.  This strategy is done when ``filter_union = False``,</span>
<span class="sd">           which is the default setting.</span>

<span class="sd">        2) ``bad_union = True``</span>

<span class="sd">          Mark every MSID in the set as bad at the interpolated time if *any*</span>
<span class="sd">          of them are bad at that time.  This stricter version is required when it</span>
<span class="sd">          is important that the MSIDs be truly correlated in time.  For instance</span>
<span class="sd">          this is needed for attitude quaternions since all four values must be</span>
<span class="sd">          from the exact same telemetry sample.  If you are not sure, this is the</span>
<span class="sd">          safer option.</span>

<span class="sd">        :param dt: time step (sec, default=328.0)</span>
<span class="sd">        :param start: start of interpolation period (DateTime format)</span>
<span class="sd">        :param stop: end of interpolation period (DateTime format)</span>
<span class="sd">        :param filter_bad: filter bad values</span>
<span class="sd">        :param times: array of times for interpolation (default=None)</span>
<span class="sd">        :param bad_union: filter union of bad values after interpolating</span>
<span class="sd">        :param copy: return a new copy instead of in-place update (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">Ska.Numpy</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="n">msids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># MSID objects in the MSIDset</span>

        <span class="c1"># Ensure that tstart / tstop is entirely within the range of available</span>
        <span class="c1"># data fetched from the archive.</span>
        <span class="n">max_fetch_tstart</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">msid</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">)</span>
        <span class="n">min_fetch_tstop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">msid</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">kwarg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If &quot;times&quot; keyword is set then &quot;dt&quot;, &quot;start&quot;, &#39;</span>
                                 <span class="s1">&#39;and &quot;stop&quot; cannot be set&#39;</span><span class="p">)</span>
            <span class="c1"># Use user-supplied times that are within the range of telemetry.</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span> <span class="o">&gt;=</span> <span class="n">max_fetch_tstart</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">times</span> <span class="o">&lt;=</span> <span class="n">min_fetch_tstop</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the nominal tstart / tstop range</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="mf">328.0</span> <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dt</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span> <span class="k">if</span> <span class="n">start</span> <span class="k">else</span> <span class="n">obj</span><span class="o">.</span><span class="n">tstart</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span> <span class="k">if</span> <span class="n">stop</span> <span class="k">else</span> <span class="n">obj</span><span class="o">.</span><span class="n">tstop</span>

            <span class="n">tstart</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">max_fetch_tstart</span><span class="p">)</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">min_fetch_tstop</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">tstop</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">//</span> <span class="n">dt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">tstart</span>

        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_bad</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bad_union</span><span class="p">:</span>
                <span class="n">msid</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Interpolating index for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">msid</span><span class="o">.</span><span class="n">msid</span><span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">Ska</span><span class="o">.</span><span class="n">Numpy</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">msid</span><span class="o">.</span><span class="n">times</span><span class="p">)),</span>
                                            <span class="n">msid</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">times</span><span class="p">,</span>
                                            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Slicing on indexes&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">msid</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                <span class="n">colvals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">colname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">colvals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">colname</span><span class="p">,</span> <span class="n">colvals</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>

            <span class="c1"># Make a new attribute times0 that stores the nearest neighbor</span>
            <span class="c1"># interpolated times.  Then set the MSID times to be the common</span>
            <span class="c1"># interpolation times.</span>
            <span class="n">msid</span><span class="o">.</span><span class="n">times0</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">times</span>
            <span class="n">msid</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">bad_union</span><span class="p">:</span>
            <span class="n">common_bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">msid</span><span class="o">.</span><span class="n">stat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">msid</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: </span><span class="si">{!r}</span><span class="s1"> MSID has bad values already filtered.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                  <span class="s1">&#39;This prevents `filter_bad_union` from working as expected.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                  <span class="s1">&#39;Use MSIDset (not Msidset) with filter_bad=False.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">msid</span><span class="o">.</span><span class="n">bads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 5min and daily stats have no bad values</span>
                    <span class="n">common_bads</span> <span class="o">|=</span> <span class="n">msid</span><span class="o">.</span><span class="n">bads</span>

            <span class="c1"># Apply the common bads array and optional filter out these bad values</span>
            <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
                <span class="n">msid</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="n">common_bads</span>
                <span class="k">if</span> <span class="n">filter_bad</span><span class="p">:</span>
                    <span class="n">msid</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>

            <span class="c1"># Filter MSIDset-level times attr to match invididual MSIDs if filter_bad is True</span>
            <span class="k">if</span> <span class="n">filter_bad</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">~</span><span class="n">common_bads</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="MSIDset.write_zip"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.MSIDset.write_zip">[docs]</a>    <span class="k">def</span> <span class="nf">write_zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write MSIDset to a zip file named ``filename``</span>

<span class="sd">        Within the zip archive the data for each MSID in the set will be stored</span>
<span class="sd">        in csv format with the name &lt;msid_name&gt;.csv.</span>

<span class="sd">        :param filename: output zipfile name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">append</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">msid</span><span class="o">.</span><span class="n">write_zip</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>
            <span class="n">append</span> <span class="o">=</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="Msid"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.Msid">[docs]</a><span class="k">class</span> <span class="nc">Msid</span><span class="p">(</span><span class="n">MSID</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetch data from the engineering telemetry archive into an MSID object.</span>
<span class="sd">    Same as MSID class but with filter_bad=True by default.</span>

<span class="sd">    :param msid: name of MSID (case-insensitive)</span>
<span class="sd">    :param start: start date of telemetry (Chandra.Time compatible)</span>
<span class="sd">    :param stop: stop date of telemetry (current time if not supplied)</span>
<span class="sd">    :param filter_bad: automatically filter out bad values</span>
<span class="sd">    :param stat: return 5-minute or daily statistics (&#39;5min&#39; or &#39;daily&#39;)</span>
<span class="sd">    :param unit_system: Unit system (cxc|eng|sci, default=current units)</span>

<span class="sd">    :returns: MSID instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">units</span> <span class="o">=</span> <span class="n">UNITS</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">LAUNCH_DATE</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Msid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                                   <span class="n">filter_bad</span><span class="o">=</span><span class="n">filter_bad</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="n">stat</span><span class="p">)</span></div>


<div class="viewcode-block" id="Msidset"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.Msidset">[docs]</a><span class="k">class</span> <span class="nc">Msidset</span><span class="p">(</span><span class="n">MSIDset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fetch a set of MSIDs from the engineering telemetry archive.</span>
<span class="sd">    Same as MSIDset class but with filter_bad=True by default.</span>

<span class="sd">    :param msids: list of MSID names (case-insensitive)</span>
<span class="sd">    :param start: start date of telemetry (Chandra.Time compatible)</span>
<span class="sd">    :param stop: stop date of telemetry (current time if not supplied)</span>
<span class="sd">    :param filter_bad: automatically filter out bad values</span>
<span class="sd">    :param stat: return 5-minute or daily statistics (&#39;5min&#39; or &#39;daily&#39;)</span>
<span class="sd">    :param unit_system: Unit system (cxc|eng|sci, default=current units)</span>

<span class="sd">    :returns: Dict-like object containing MSID instances keyed by MSID name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MSID</span> <span class="o">=</span> <span class="n">MSID</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">LAUNCH_DATE</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Msidset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                                      <span class="n">filter_bad</span><span class="o">=</span><span class="n">filter_bad</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="n">stat</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">HrcSsMsid</span><span class="p">(</span><span class="n">Msid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetch data from the engineering telemetry archive into an MSID object.</span>
<span class="sd">    Same as MSID class but with filter_bad=True by default.</span>

<span class="sd">    :param msid: name of MSID (case-insensitive)</span>
<span class="sd">    :param start: start date of telemetry (Chandra.Time compatible)</span>
<span class="sd">    :param stop: stop date of telemetry (current time if not supplied)</span>
<span class="sd">    :param filter_bad: automatically filter out bad values</span>
<span class="sd">    :param stat: return 5-minute or daily statistics (&#39;5min&#39; or &#39;daily&#39;)</span>
<span class="sd">    :param unit_system: Unit system (cxc|eng|sci, default=current units)</span>

<span class="sd">    :returns: MSID instance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">units</span> <span class="o">=</span> <span class="n">UNITS</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">LAUNCH_DATE</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ss_msids</span> <span class="o">=</span> <span class="s1">&#39;2TLEV1RT 2VLEV1RT 2SHEV1RT 2TLEV2RT 2VLEV2RT 2SHEV2RT&#39;</span>
        <span class="k">if</span> <span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ss_msids</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MSID </span><span class="si">{}</span><span class="s1"> is not in HRC secondary science (</span><span class="si">{}</span><span class="s1">)&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">ss_msids</span><span class="p">))</span>

        <span class="c1"># If this is not full-resolution then add boolean bads mask to individual MSIDs</span>
        <span class="n">msids</span> <span class="o">=</span> <span class="p">[</span><span class="n">msid</span><span class="p">,</span> <span class="s1">&#39;HRC_SS_HK_BAD&#39;</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">MSIDset</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="n">stat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="c1"># Set bad mask</span>
        <span class="n">i_bads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;HRC_SS_HK_BAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;HRC_SS_HK_BAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bads</span><span class="p">[</span><span class="n">i_bads</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># For full-resolution smear the bad mask out by +/- 5 samples</span>
        <span class="k">if</span> <span class="n">stat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_bad</span> <span class="ow">in</span> <span class="n">i_bads</span><span class="p">:</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i_bad</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">i_bad</span> <span class="o">+</span> <span class="mi">5</span>
                <span class="n">out</span><span class="p">[</span><span class="s1">&#39;HRC_SS_HK_BAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bads</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Finally interpolate and filter out bad values</span>
        <span class="n">out</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">bad_union</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">memoized</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator that caches a function&#39;s return value each time it is called.</span>
<span class="sd">    If called later with the same arguments, the cached value is returned, and</span>
<span class="sd">    not re-evaluated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># uncachable -- for instance, passing a list as an argument.</span>
            <span class="c1"># Better to not cache than to blow up entirely.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the function&#39;s docstring.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span>


<div class="viewcode-block" id="get_time_range"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.get_time_range">[docs]</a><span class="k">def</span> <span class="nf">get_time_range</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the time range for the given ``msid``.</span>

<span class="sd">    :param msid: MSID name</span>
<span class="sd">    :param format: Output format (DateTime format, e.g. &#39;secs&#39;, &#39;date&#39;, &#39;greta&#39;)</span>
<span class="sd">    :returns: (tstart, tstop) in CXC seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MSID</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">_cache_ft</span><span class="p">():</span>
        <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="n">MSID</span><span class="p">]</span>
        <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">msid_files</span><span class="p">[</span><span class="s1">&#39;msid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="nd">@local_or_remote_function</span><span class="p">(</span><span class="s2">&quot;Getting time range from Ska eng archive server...&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_time_data_from_server</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">tables</span>
            <span class="n">open_file</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="s1">&#39;open_file&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tables</span><span class="o">.</span><span class="n">openFile</span>
            <span class="n">h5</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">h5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">CONTENT_TIME_RANGES</span><span class="p">:</span>
            <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span> <span class="o">=</span> <span class="n">CONTENT_TIME_RANGES</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span> <span class="o">=</span> <span class="n">get_time_data_from_server</span><span class="p">(</span><span class="n">_split_path</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">CONTENT_TIME_RANGES</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">tstart</span><span class="p">),</span> <span class="nb">format</span><span class="p">)</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(</span><span class="n">tstop</span><span class="p">),</span> <span class="nb">format</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span></div>


<div class="viewcode-block" id="get_telem"><a class="viewcode-back" href="../../../fetch.html#Ska.engarchive.fetch.get_telem">[docs]</a><span class="k">def</span> <span class="nf">get_telem</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">unit_system</span><span class="o">=</span><span class="s1">&#39;eng&#39;</span><span class="p">,</span>
              <span class="n">interpolate_dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">time_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">max_fetch_Mb</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">max_output_Mb</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    High-level routine to get telemetry for one or more MSIDs and perform</span>
<span class="sd">    common processing functions:</span>

<span class="sd">      - Fetch a set of MSIDs over a time range, specifying the sampling as</span>
<span class="sd">        either full-resolution, 5-minute, or daily data.</span>
<span class="sd">      - Filter out bad or missing data.</span>
<span class="sd">      - Interpolate (resample) all MSID values to a common uniformly-spaced time sequence.</span>
<span class="sd">      - Remove or select time intervals corresponding to specified Kadi event types.</span>
<span class="sd">      - Change the time format from CXC seconds (seconds since 1998.0) to something more</span>
<span class="sd">        convenient like GRETA time.</span>
<span class="sd">      - Write the MSID telemetry data to a zipfile.</span>

<span class="sd">    :param msids: MSID(s) to fetch (string or list of strings)&#39;)</span>
<span class="sd">    :param start: Start time for data fetch (default=&lt;stop&gt; - 30 days)</span>
<span class="sd">    :param stop: Stop time for data fetch (default=NOW)</span>
<span class="sd">    :param sampling: Data sampling (full | 5min | daily) (default=full)</span>
<span class="sd">    :param unit_system: Unit system for data (eng | sci | cxc) (default=eng)</span>
<span class="sd">    :param interpolate_dt: Interpolate to uniform time steps (secs, default=None)</span>
<span class="sd">    :param remove_events: Remove kadi events expression (default=None)</span>
<span class="sd">    :param select_events: Select kadi events expression (default=None)</span>
<span class="sd">    :param time_format: Output time format (secs|date|greta|jd|..., default=secs)</span>
<span class="sd">    :param outfile: Output file name (default=None)</span>
<span class="sd">    :param quiet: Suppress run-time logging output (default=False)</span>
<span class="sd">    :param max_fetch_Mb: Max allowed memory (Mb) for fetching (default=1000)</span>
<span class="sd">    :param max_output_Mb: Max allowed memory (Mb) for file output (default=100)</span>

<span class="sd">    :returns: MSIDset object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.get_telem</span> <span class="kn">import</span> <span class="n">get_telem</span>
    <span class="k">return</span> <span class="n">get_telem</span><span class="p">(</span><span class="n">msids</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">unit_system</span><span class="p">,</span>
                     <span class="n">interpolate_dt</span><span class="p">,</span> <span class="n">remove_events</span><span class="p">,</span> <span class="n">select_events</span><span class="p">,</span>
                     <span class="n">time_format</span><span class="p">,</span> <span class="n">outfile</span><span class="p">,</span> <span class="n">quiet</span><span class="p">,</span>
                     <span class="n">max_fetch_Mb</span><span class="p">,</span> <span class="n">max_output_Mb</span><span class="p">)</span></div>


<span class="nd">@lru_cache_timed</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_interval</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the approximate row intervals that enclose the specified ``tstart`` and</span>
<span class="sd">    ``tstop`` times for the ``content`` type.</span>

<span class="sd">    The output of this function is cached with an LRU cache of the most recent</span>
<span class="sd">    1000 results. The cache expires every 10 minutes to ensure that a persistent</span>
<span class="sd">    session will get new data if the archive gets updated.</span>

<span class="sd">    :param content: content type (e.g. &#39;pcad3eng&#39;, &#39;thm1eng&#39;)</span>
<span class="sd">    :param tstart: start time (CXC seconds)</span>
<span class="sd">    :param tstop: stop time (CXC seconds)</span>

<span class="sd">    :returns: rowslice</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ft</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">content</span>

    <span class="nd">@local_or_remote_function</span><span class="p">(</span><span class="s2">&quot;Getting interval data from &quot;</span> <span class="o">+</span>
                              <span class="s2">&quot;DB on Ska eng archive server...&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_interval_from_db</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">server</span><span class="p">):</span>

        <span class="kn">import</span> <span class="nn">Ska.DBI</span>

        <span class="n">db</span> <span class="o">=</span> <span class="n">Ska</span><span class="o">.</span><span class="n">DBI</span><span class="o">.</span><span class="n">DBI</span><span class="p">(</span><span class="n">dbi</span><span class="o">=</span><span class="s1">&#39;sqlite&#39;</span><span class="p">,</span> <span class="n">server</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">server</span><span class="p">))</span>

        <span class="n">query_row</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fetchone</span><span class="p">(</span><span class="s1">&#39;SELECT tstart, rowstart FROM archfiles &#39;</span>
                                <span class="s1">&#39;WHERE filetime &lt; ? order by filetime desc&#39;</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">tstart</span><span class="p">,))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query_row</span><span class="p">:</span>
            <span class="n">query_row</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fetchone</span><span class="p">(</span><span class="s1">&#39;SELECT tstart, rowstart FROM archfiles &#39;</span>
                                    <span class="s1">&#39;order by filetime asc&#39;</span><span class="p">)</span>

        <span class="n">rowstart</span> <span class="o">=</span> <span class="n">query_row</span><span class="p">[</span><span class="s1">&#39;rowstart&#39;</span><span class="p">]</span>

        <span class="n">query_row</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fetchone</span><span class="p">(</span><span class="s1">&#39;SELECT tstop, rowstop FROM archfiles &#39;</span>
                                <span class="s1">&#39;WHERE filetime &gt; ? order by filetime asc&#39;</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">tstop</span><span class="p">,))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query_row</span><span class="p">:</span>
            <span class="n">query_row</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">fetchone</span><span class="p">(</span><span class="s1">&#39;SELECT tstop, rowstop FROM archfiles &#39;</span>
                                    <span class="s1">&#39;order by filetime desc&#39;</span><span class="p">)</span>

        <span class="n">rowstop</span> <span class="o">=</span> <span class="n">query_row</span><span class="p">[</span><span class="s1">&#39;rowstop&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">rowstart</span><span class="p">,</span> <span class="n">rowstop</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">get_interval_from_db</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">_split_path</span><span class="p">(</span><span class="n">msid_files</span><span class="p">[</span><span class="s1">&#39;archfiles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">))</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">_cache_ft</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cache the global filetype ``ft`` context variable so that fetch operations</span>
<span class="sd">    do not corrupt user values of ``ft``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ft_cache_pickle</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">ft_cache</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">ft_cache_pickle</span><span class="p">)</span>
        <span class="n">ft</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ft_cache</span><span class="p">)</span>
        <span class="n">delkeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ft</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ft_cache</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">delkeys</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">ft</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">_set_msid_files_basedir</span><span class="p">(</span><span class="n">datestart</span><span class="p">,</span> <span class="n">msid_files</span><span class="o">=</span><span class="n">msid_files</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If datestart is before 2000:001:00:00:00 then use the 1999 archive files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cache_basedir</span> <span class="o">=</span> <span class="n">msid_files</span><span class="o">.</span><span class="n">basedir</span>
        <span class="k">if</span> <span class="n">datestart</span> <span class="o">&lt;</span> <span class="n">DATE2000_LO</span><span class="p">:</span>
            <span class="c1"># Note: don&#39;t use os.path.join because ENG_ARCHIVE and basedir must</span>
            <span class="c1"># use linux &#39;/&#39; convention but this might be running on Windows.</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="n">msid_files</span><span class="o">.</span><span class="n">basedir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">)</span>
            <span class="n">msid_files</span><span class="o">.</span><span class="n">basedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_</span> <span class="o">+</span> <span class="s1">&#39;/1999&#39;</span> <span class="k">for</span> <span class="n">dir_</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">)</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">msid_files</span><span class="o">.</span><span class="n">basedir</span> <span class="o">=</span> <span class="n">cache_basedir</span>


<span class="k">def</span> <span class="nf">_fix_ctu_dwell_mode_bads</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">bads</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Because of an issue related to the placement of the dwell mode flag, MSIDs that get</span>
<span class="sd">    stepped on in dwell mode get a bad value at the beginning of a dwell mode, while the</span>
<span class="sd">    dwell mode values (DWELLnn) get a bad value at the end.  This does a simple</span>
<span class="sd">    brute-force fix of expanding any section of bad values by ones sample in the</span>
<span class="sd">    appropriate direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MSID</span> <span class="o">=</span> <span class="n">msid</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">stepped_on_msids</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;4PRT5BT&#39;</span><span class="p">,</span> <span class="s1">&#39;4RT585T&#39;</span><span class="p">,</span> <span class="s1">&#39;AFLCA3BI&#39;</span><span class="p">,</span> <span class="s1">&#39;AIRU1BT&#39;</span><span class="p">,</span> <span class="s1">&#39;CSITB5V&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;CUSOAOVN&#39;</span><span class="p">,</span> <span class="s1">&#39;ECNV3V&#39;</span><span class="p">,</span> <span class="s1">&#39;PLAED4ET&#39;</span><span class="p">,</span> <span class="s1">&#39;PR1TV01T&#39;</span><span class="p">,</span> <span class="s1">&#39;TCYLFMZM&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;TOXTSUPN&#39;</span><span class="p">,</span> <span class="s1">&#39;ES1P5CV&#39;</span><span class="p">,</span> <span class="s1">&#39;ES2P5CV&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">MSID</span> <span class="ow">in</span> <span class="n">stepped_on_msids</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;DWELL\d\d&#39;</span><span class="p">,</span> <span class="n">MSID</span><span class="p">):</span>
        <span class="c1"># Find transitions from good value to bad value.  Turn that</span>
        <span class="c1"># good value to bad to extend the badness by one sample.</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">bads</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bads</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># noqa</span>
        <span class="n">bads</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">bads</span>


<span class="k">def</span> <span class="nf">add_logging_handler</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                        <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">handler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Configure logging for fetch module.</span>

<span class="sd">    :param level: logging level (logging.DEBUG, logging.INFO, etc)</span>
<span class="sd">    :param formatter: logging.Formatter (default: Formatter(&#39;%(funcName)s: %(message)s&#39;))</span>
<span class="sd">    :param handler: logging.Handler (default: StreamHandler())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">formatter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(funcName)s</span><span class="s1">: </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>

    <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_plural</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return English plural of ``x``.  Super-simple and only valid for the</span>
<span class="sd">    known small set of cases within fetch where it will get applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="s1">&#39;es&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">))</span> <span class="k">else</span> <span class="n">x</span> <span class="o">+</span> <span class="s1">&#39;s&#39;</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/ska.png" alt="Logo"/>
            </a></p><h3>Page Contents</h3>


<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011, Tom Aldcroft.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.1.2. &nbsp;
  </p>
</footer>
  </body>
</html>