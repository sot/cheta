
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fetch Tutorial &#8212; Eng archive 4.54.1 documentation</title>
    <link rel="stylesheet" href="_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Command-line fetch" href="ska_fetch.html" />
    <link rel="prev" title="Ska Analysis Tutorial" href="tutorial.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="index.html"><span id="logotext1">Ska! </span><span id="logotext2">Cheta</span><span id="logotext3"></span></a>
  <ul>
    
    <li><a class="home" title="Homepage" href="https://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc">
        <span id="logotext1">ska</span><span id="logotext2">tools</span>
    </a></li>
    <li><a title="General Index" href="genindex.html">Index</a></li>
    <li><a title="Module Index" href="py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="ska_fetch.html" title="Command-line fetch">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="tutorial.html" title="Ska Analysis Tutorial">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="index.html">Eng archive 4.54.1 documentation</a>
	 &#187;
      </li>
      
      <li>Fetch Tutorial</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fetch-tutorial">
<h1>Fetch Tutorial<a class="headerlink" href="#fetch-tutorial" title="Permalink to this headline">¶</a></h1>
<p>The python module <code class="docutils literal notranslate"><span class="pre">Ska.engarchive.fetch</span></code> provides a simple interface to the
engineering archive data files.  Using the module functions it is easy to
retrieve data over a time range for a single MSID or a related set of MSIDs.
The data are return as MSID objects that contain not only the telemetry timestamps
and values but also various other data arrays and MSID metadata.</p>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p><strong>First fetch</strong></p>
<p>The basic process of fetching data always starts with importing the module
into the python session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Ska.engarchive.fetch</span> <span class="k">as</span> <span class="nn">fetch</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">fetch</span></code> part of the <code class="docutils literal notranslate"><span class="pre">import</span></code> statement just creates an short alias
to avoid always typing the somewhat lengthy <code class="docutils literal notranslate"><span class="pre">Ska.engarchive.fetch.MSID(..)</span></code>.
Fetching and plotting full time-resolution data for a single MSID is then quite
easy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:007&#39;</span><span class="p">)</span> <span class="c1"># (MSID, start, stop)</span>
<span class="n">clf</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tephin</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/first.png" src="_images/first.png" />
<p>The <code class="docutils literal notranslate"><span class="pre">tephin</span></code> variable returned by <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> is an <code class="docutils literal notranslate"><span class="pre">MSID</span></code> object and
we can access the various object attributes with <code class="docutils literal notranslate"><span class="pre">&lt;object&gt;.&lt;attr&gt;</span></code>.  The
timestamps <code class="docutils literal notranslate"><span class="pre">tephin.times</span></code> and the telemetry values <code class="docutils literal notranslate"><span class="pre">tephin.vals</span></code> are both
numpy arrays.  As such you can inspect them and perform numpy operations and
explore their methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">tephin</span><span class="p">)</span>
<span class="nb">type</span><span class="p">(</span><span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>
<span class="n">help</span> <span class="n">tephin</span><span class="o">.</span><span class="n">vals</span>
<span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="o">.&lt;</span><span class="n">TAB</span><span class="o">&gt;</span>
<span class="n">tephin</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Default start and stop values</strong></p>
<p>If you do not provide a value for the <code class="docutils literal notranslate"><span class="pre">start</span></code> time, then it defaults to
the beginning of the mission (1999:204 = July 23, 1999).  If you do not provide
a stop time then it defaults to the latest available data in the archive.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="s1">&#39;2001:001&#39;</span><span class="p">)</span> <span class="c1"># Launch through 2001:001</span>
<span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="s1">&#39;2010:001&#39;</span><span class="p">)</span> <span class="c1"># 2010:001 through NOW</span>
<span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">)</span> <span class="c1"># Same as previous</span>
<span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">)</span> <span class="c1"># Launch through NOW</span>
</pre></div>
</div>
<p><strong>Other details</strong></p>
<p>If you are wondering what time range of data is available for a particular MSID
use the <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.get_time_range" title="Ska.engarchive.fetch.get_time_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_time_range()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fetch</span><span class="o">.</span><span class="n">get_time_range</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;date&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="s1">&#39;1999:365:22:40:33.076&#39;</span><span class="p">,</span> <span class="s1">&#39;2013:276:12:04:39.361&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The name of the variable holding the MSID object is independent of the MSID name
itself.  Case is not important when specifying the MSID name so one might do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pcad_mode</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;AOpcadMD&#39;</span><span class="p">,</span> <span class="s1">&#39;2009Jan01 at 12:00:00.000&#39;</span><span class="p">,</span> <span class="s1">&#39;2009-01-12T14:15:16&#39;</span><span class="p">)</span>
<span class="n">pcad_mode</span><span class="o">.</span><span class="n">msid</span>  <span class="c1"># MSID name as entered by user</span>
<span class="n">pcad_mode</span><span class="o">.</span><span class="n">MSID</span>  <span class="c1"># Upper-cased version used internally</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">times</span></code> attribute gives the timestamps in elapsed seconds since
1998-01-01T00:00:00.  This is the start of 1998 in Terrestrial Time (TT) and forms
the basis for time for all CXC data files.  In order to make life inconvenient
1998-01-01T00:00:00 is actually 1997:365:23:58:56.816 (UTC).  This stems from
the difference of around 64 seconds between TT and UTC.</p>
</div>
<div class="section" id="date-and-time-formats">
<h2>Date and time formats<a class="headerlink" href="#date-and-time-formats" title="Permalink to this headline">¶</a></h2>
<p>The Ska engineering telemetry archive tools support a wide
range of formats for representing date-time stamps.  Note that within this and
other documents for this tool suite, the words ‘time’ and ‘date’ are used
interchangably to mean a date-time stamp.</p>
<p>The available formats are listed in the table below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 71%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Format</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>System</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>secs</p></td>
<td><p>Elapsed seconds since 1998-01-01T00:00:00</p></td>
<td><p>tt</p></td>
</tr>
<tr class="row-odd"><td><p>numday</p></td>
<td><p>DDDD:hh:mm:ss.ss… Elapsed days and time</p></td>
<td><p>utc</p></td>
</tr>
<tr class="row-even"><td><p>jd*</p></td>
<td><p>Julian Day</p></td>
<td><p>utc</p></td>
</tr>
<tr class="row-odd"><td><p>mjd*</p></td>
<td><p>Modified Julian Day = JD - 2400000.5</p></td>
<td><p>utc</p></td>
</tr>
<tr class="row-even"><td><p>date</p></td>
<td><p>YYYY:DDD:hh:mm:ss.ss..</p></td>
<td><p>utc</p></td>
</tr>
<tr class="row-odd"><td><p>caldate</p></td>
<td><p>YYYYMonDD at hh:mm:ss.ss..</p></td>
<td><p>utc</p></td>
</tr>
<tr class="row-even"><td><p>fits</p></td>
<td><p>FITS date/time format YYYY-MM-DDThh:mm:ss.ss..</p></td>
<td><p>tt</p></td>
</tr>
<tr class="row-odd"><td><p>unix*</p></td>
<td><p>Unix time (since 1970.0)</p></td>
<td><p>utc</p></td>
</tr>
<tr class="row-even"><td><p>greta</p></td>
<td><p>YYYYDDD.hhmmss[sss]</p></td>
<td><p>utc</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">*</span></code> Ambiguous for input parsing and only available as output formats.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">date</span></code> format one can supply only YYYY:DDD in which case 12:00:00.000
is implied.</p>
<p>The default time “System” for the different formats is either <code class="docutils literal notranslate"><span class="pre">tt</span></code>
(Terrestrial Time) or <code class="docutils literal notranslate"><span class="pre">utc</span></code> (UTC).  Since TT differs from UTC by around 64
seconds it is important to be consistent in specifying the time format.</p>
<p>Converting between units is straightforward with the <code class="docutils literal notranslate"><span class="pre">Chandra.Time</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Chandra.Time</span>
<span class="n">datetime</span> <span class="o">=</span> <span class="n">Chandra</span><span class="o">.</span><span class="n">Time</span><span class="o">.</span><span class="n">DateTime</span><span class="p">(</span><span class="mf">126446464.184</span><span class="p">)</span>
<span class="n">datetime</span><span class="o">.</span><span class="n">date</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="s1">&#39;2002:003:12:00:00.000&#39;</span>

<span class="n">datetime</span><span class="o">.</span><span class="n">greta</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="s1">&#39;2002003.120000000&#39;</span>

<span class="n">Chandra</span><span class="o">.</span><span class="n">Time</span><span class="o">.</span><span class="n">DateTime</span><span class="p">(</span><span class="s1">&#39;2009:235:12:13:14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">secs</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="mf">367416860.18399996</span>
</pre></div>
</div>
</div>
<div class="section" id="exporting-to-csv">
<h2>Exporting to CSV<a class="headerlink" href="#exporting-to-csv" title="Permalink to this headline">¶</a></h2>
<p>If you want to move the fetch data to your local machine an <code class="docutils literal notranslate"><span class="pre">MSID</span></code> or
<code class="docutils literal notranslate"><span class="pre">MSIDset</span></code> can be exported as ASCII data table(s) in CSV format.  This can
easily be imported into Excel or other PC applications.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">biases</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aogbias1&#39;</span><span class="p">,</span> <span class="s1">&#39;aogbias2&#39;</span><span class="p">,</span> <span class="s1">&#39;aogbias3&#39;</span><span class="p">],</span> <span class="s1">&#39;2002:001&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;daily&#39;</span><span class="p">)</span>
<span class="n">biases</span><span class="o">.</span><span class="n">write_zip</span><span class="p">(</span><span class="s1">&#39;biases.zip&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To suspend the ipython shell and look at the newly created file do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">Ctrl</span><span class="o">&gt;-</span><span class="n">z</span>

<span class="o">%</span> <span class="n">ls</span> <span class="o">-</span><span class="n">l</span> <span class="n">biases</span><span class="o">.</span><span class="n">zip</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span> <span class="mi">1</span> <span class="n">aldcroft</span> <span class="n">aldcroft</span> <span class="mi">366924</span> <span class="n">Dec</span>  <span class="mi">4</span> <span class="mi">17</span><span class="p">:</span><span class="mi">07</span> <span class="n">biases</span><span class="o">.</span><span class="n">zip</span>

<span class="o">%</span> <span class="n">unzip</span> <span class="o">-</span><span class="n">l</span> <span class="n">biases</span><span class="o">.</span><span class="n">zip</span>
<span class="n">Archive</span><span class="p">:</span>  <span class="n">biases</span><span class="o">.</span><span class="n">zip</span>
  <span class="n">Length</span>     <span class="n">Date</span>   <span class="n">Time</span>    <span class="n">Name</span>
 <span class="o">--------</span>    <span class="o">----</span>   <span class="o">----</span>    <span class="o">----</span>
   <span class="mi">510809</span>  <span class="mi">12</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">09</span> <span class="mi">17</span><span class="p">:</span><span class="mi">02</span>   <span class="n">aogbias1</span><span class="o">.</span><span class="n">csv</span>
   <span class="mi">504556</span>  <span class="mi">12</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">09</span> <span class="mi">17</span><span class="p">:</span><span class="mi">02</span>   <span class="n">aogbias2</span><span class="o">.</span><span class="n">csv</span>
   <span class="mi">504610</span>  <span class="mi">12</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">09</span> <span class="mi">17</span><span class="p">:</span><span class="mi">02</span>   <span class="n">aogbias3</span><span class="o">.</span><span class="n">csv</span>
 <span class="o">--------</span>                   <span class="o">-------</span>
  <span class="mi">1519975</span>                   <span class="mi">3</span> <span class="n">files</span>
</pre></div>
</div>
<p>To resume your <code class="docutils literal notranslate"><span class="pre">ipython</span></code> session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">fg</span>
</pre></div>
</div>
<p>From a separate local cygwin or terminal window then retrieve the zip file and
unzip as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scp</span> <span class="n">ccosmos</span><span class="o">.</span><span class="n">cfa</span><span class="o">.</span><span class="n">harvard</span><span class="o">.</span><span class="n">edu</span><span class="p">:</span><span class="n">biases</span><span class="o">.</span><span class="n">zip</span> <span class="o">./</span>
<span class="n">unzip</span> <span class="n">biases</span><span class="o">.</span><span class="n">zip</span>
</pre></div>
</div>
</div>
<div class="section" id="plotting-time-data">
<h2>Plotting time data<a class="headerlink" href="#plotting-time-data" title="Permalink to this headline">¶</a></h2>
<p>Even though seconds since 1998.0 is convenient for computations it isn’t so
natural for humans.  As mentioned the <code class="docutils literal notranslate"><span class="pre">Chandra.Time</span></code> module can help with
converting between formats but for making plots we use the
<a class="reference external" href="http://cxc.harvard.edu/mta/ASPECT/tool_doc/pydocs/Ska.Matplotlib.html#Ska.Matplotlib.plot_cxctime">plot_cxctime()</a>
function of the <code class="docutils literal notranslate"><span class="pre">Ska.Matplotlib</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Ska.Matplotlib</span> <span class="kn">import</span> <span class="n">plot_cxctime</span>
<span class="n">clf</span><span class="p">()</span>
<span class="n">plot_cxctime</span><span class="p">(</span><span class="n">tephin</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>
</pre></div>
</div>
<p>An even simpler way to make the same plot is with the
<a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.plot" title="Ska.engarchive.fetch.MSID.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tephin</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>That looks better:</p>
<img alt="_images/plot_cxctime.png" src="_images/plot_cxctime.png" />
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.plot" title="Ska.engarchive.fetch.MSID.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot()</span></code></a> method accepts any arguments
work with the Matplotlib <a class="reference external" href="http://matplotlib.sourceforge.net/api/pyplot_api.html#matplotlib.pyplot.plot_date">plot_date()</a>
function</p>
</div>
</div>
<div class="section" id="interactive-plotting">
<h2>Interactive plotting<a class="headerlink" href="#interactive-plotting" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.iplot" title="Ska.engarchive.fetch.MSID.iplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">iplot()</span></code></a> function is a handy way to quickly
explore MSID data over a wide range of time scales, from seconds to the entire
mission in a few key presses.  The function automatically fetches data from
the archive as needed.</p>
<p>When called this method opens a new plot figure (or clears the current figure)
and plots the MSID <code class="docutils literal notranslate"><span class="pre">vals</span></code> versus <code class="docutils literal notranslate"><span class="pre">times</span></code>.  This plot can be panned or
zoomed arbitrarily and the data values will be fetched from the archive as
needed.  Depending on the time scale, <code class="docutils literal notranslate"><span class="pre">iplot</span></code> will display either full
resolution, 5-minute, or daily values.  For 5-minute and daily values the min
and max values are also plotted.</p>
<p>Once the plot is displayed and the window is selected by clicking in it, the
plot limits can be controlled by the usual methods (window selection, pan /
zoom).  In addition following key commands are recognized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>a: autoscale for full data range in x and y
m: toggle plotting of min/max values
p: pan at cursor x
y: toggle autoscaling of y-axis
z: zoom at cursor x
?: print help
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aoattqt1&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2012:001&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;5min&#39;</span><span class="p">)</span>
<span class="n">dat</span><span class="o">.</span><span class="n">iplot</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.iplot" title="Ska.engarchive.fetch.MSID.iplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">iplot()</span></code></a> and
<a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.plot" title="Ska.engarchive.fetch.MSID.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot()</span></code></a> functions support plotting
state-valued MSIDs such as <code class="docutils literal notranslate"><span class="pre">AOPCADMD</span></code> or <code class="docutils literal notranslate"><span class="pre">AOUNLOAD</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aopcadmd&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:185&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:195&#39;</span><span class="p">)</span>
<span class="n">dat</span><span class="o">.</span><span class="n">iplot</span><span class="p">()</span>
<span class="n">grid</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/iplot_aopcadmode.png" src="_images/iplot_aopcadmode.png" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.iplot" title="Ska.engarchive.fetch.MSID.iplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">iplot()</span></code></a> method is not meant for use
within scripts, and may give unexpected results if used in combination with
other plotting commands directed at the same plot figure.  Instead one
should use the MSID <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.plot" title="Ska.engarchive.fetch.MSID.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot()</span></code></a> method in this
case.</p>
</div>
</div>
<div class="section" id="data-filtering">
<h2>Data filtering<a class="headerlink" href="#data-filtering" title="Permalink to this headline">¶</a></h2>
<p>Often one needs to filter or select subsets of the raw telemetry that gets fetched from
the archive in order to use the values in analysis.  Here we describe the ways to
accomplish this in different circumstances.</p>
<div class="section" id="event-interval-filtering">
<span id="event-intervals"></span><h3>Event interval filtering<a class="headerlink" href="#event-interval-filtering" title="Permalink to this headline">¶</a></h3>
<p>The first case is when one needs to either select or remove specific intervals of
telemetry values from a full <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> or <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a> object based on known
spacecraft events.  For instance when analyzing OBC rate noise we need to use only data
during periods of stable Kalman lock.  Likewise it is frequently useful to exclude time
intervals during which the spacecraft was in an anomalous state and OBC telemetry is
unreliable.</p>
<div class="section" id="using-kadi">
<h4>Using Kadi<a class="headerlink" href="#using-kadi" title="Permalink to this headline">¶</a></h4>
<p>Frequently one can handle this with the <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.remove_intervals" title="Ska.engarchive.fetch.MSID.remove_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_intervals()</span></code></a>
<a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.select_intervals" title="Ska.engarchive.fetch.MSID.select_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">select_intervals()</span></code></a> methods in conjunction with the <a class="reference external" href="http://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc/kadi/#event-intervals">kadi event
intervals</a>
mechanism.</p>
<p>As a simple example, the following code fetches the pitch component of the spacecraft
rate.  The samples during maneuvers are then selected and then replotted.  This
highlights the large rates during maneuvers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:002&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span><span class="o">.</span><span class="n">iplot</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">kadi</span> <span class="kn">import</span> <span class="n">events</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span><span class="o">.</span><span class="n">select_intervals</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">manvrs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;.r&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//fetch_tutorial-1.py">Source code</a>)</p>
<p>The following code illustrates use of the <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.remove_intervals" title="Ska.engarchive.fetch.MSID.remove_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_intervals()</span></code></a>
method to select all all time intervals when the spacecraft is <em>not</em> maneuvering.  In this
case we include a pad time of 600 seconds before the start of a maneuver and 300 seconds
after the end of each maneuver.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:002&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">events</span><span class="o">.</span><span class="n">manvrs</span><span class="o">.</span><span class="n">interval_pad</span> <span class="o">=</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>  <span class="c1"># Pad before, after each maneuver (seconds)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span><span class="o">.</span><span class="n">remove_intervals</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">manvrs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//fetch_tutorial-2.py">Source code</a>)</p>
</div>
<div class="section" id="using-logical-intervals">
<h4>Using logical intervals<a class="headerlink" href="#using-logical-intervals" title="Permalink to this headline">¶</a></h4>
<p>For cases where the intervals to be filtered cannot be expressed as Kadi events,
the approach is to use the <a class="reference internal" href="utils.html#Ska.engarchive.utils.logical_intervals" title="Ska.engarchive.utils.logical_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_intervals()</span></code></a> function
located in the <code class="docutils literal notranslate"><span class="pre">Ska.engarchive.utils</span></code> module.  This function creates an intervals
table where each row represents a desired interval and includes a <code class="docutils literal notranslate"><span class="pre">datestart</span></code> and
<code class="docutils literal notranslate"><span class="pre">datestop</span></code> column.</p>
<p>For example to extract solar array temperatures when the off-nominal roll
angle is between 5 and 10 degrees you would do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Ska.engarchive.utils</span> <span class="kn">import</span> <span class="n">logical_intervals</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sa_temps</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;TSAPYT&#39;</span><span class="p">,</span><span class="s1">&#39;2010:001&#39;</span><span class="p">,</span><span class="n">stat</span><span class="o">=</span><span class="s1">&#39;5min&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roll</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;ROLL&#39;</span><span class="p">,</span><span class="s1">&#39;2010:001&#39;</span><span class="p">,</span><span class="n">stat</span><span class="o">=</span><span class="s1">&#39;5min&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">roll_off_nom</span> <span class="o">=</span> <span class="p">(</span><span class="n">roll</span><span class="o">.</span><span class="n">vals</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">roll</span><span class="o">.</span><span class="n">vals</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">off_nom_intervals</span> <span class="o">=</span> <span class="n">logical_intervals</span><span class="p">(</span><span class="n">roll</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">roll_off_nom</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sa_temps_off_nom</span> <span class="o">=</span> <span class="n">sa_temps</span><span class="o">.</span><span class="n">select_intervals</span><span class="p">(</span><span class="n">off_nom_intervals</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sa_temps</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;.r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sa_temps_off_nom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;.b&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//fetch_tutorial-3.py">Source code</a>)</p>
<p>Notice that we created a new version of the solar array temperatures MSID object called
<code class="docutils literal notranslate"><span class="pre">sa_temps_off_nom</span></code> (using <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>) instead of filtering in place.  Sometimes it is
convenient to have both the original and filtered data, e.g. when you want to plot both.</p>
<p>Note also that <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.remove_intervals" title="Ska.engarchive.fetch.MSID.remove_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_intervals()</span></code></a>
<a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID.select_intervals" title="Ska.engarchive.fetch.MSID.select_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">select_intervals()</span></code></a> will accept <em>any</em> table
with columns <code class="docutils literal notranslate"><span class="pre">datestart</span></code> / <code class="docutils literal notranslate"><span class="pre">datestop</span></code> or <code class="docutils literal notranslate"><span class="pre">tstart</span></code> / <code class="docutils literal notranslate"><span class="pre">tstop</span></code> as input.</p>
</div>
<div class="section" id="fetching-only-small-intervals">
<h4>Fetching only small intervals<a class="headerlink" href="#fetching-only-small-intervals" title="Permalink to this headline">¶</a></h4>
<p>It may be the case that you want to fetch a number of small intervals of an
MSID that is sampled at a high rate.  An example is looking at the load bus
voltage ELBV for 5 minutes after each eclipse.  Because ELBV comes down in
telemetry about 4 times per second, fetching all the values for the mission
and then selecting intervals is prohibitively expensive in memory and time.</p>
<p>There is a different mechanism that can work in these situations.  The <code class="docutils literal notranslate"><span class="pre">start</span></code>
argument to a <code class="docutils literal notranslate"><span class="pre">fetch.MSID</span></code> or <code class="docutils literal notranslate"><span class="pre">fetch.MSIDset</span></code> query can be an interval
specifier.  This might be the output of <a class="reference internal" href="utils.html#Ska.engarchive.utils.logical_intervals" title="Ska.engarchive.utils.logical_intervals"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_intervals()</span></code></a>
or it might just be a list of <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop)</span></code> tuples.  If that is the
case then fetch will iterate through those start / stop pairs, do the
fetch individually, and then stitch the whole thing back together into
a single fetch result.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Doing lots of little fetches can be very slow due to the way that
the raw data are stored.  There is a point at which it is faster
to fetch the full set of values and then throw away the ones you
don’t want.  There is no hard and fast rule and you will have to
experiment for your case.</p>
</div>
<p>The load bus example is a case where doing the little fetches is definitely
faster:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define intervals covering 5 minutes after the end of each eclipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="s1">&#39;2011:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2014:001&#39;</span>  <span class="c1"># nice Python syntax!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eclipses</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">eclipses</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">post_eclipse_intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ecl</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="n">ecl</span><span class="o">.</span><span class="n">tstop</span> <span class="o">+</span> <span class="mi">300</span><span class="p">)</span> <span class="k">for</span> <span class="n">ecl</span> <span class="ow">in</span> <span class="n">eclipses</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Grab the load bus voltage at full resolution, post eclipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elbv_post_eclipse</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;elbv&#39;</span><span class="p">,</span> <span class="n">post_eclipse_intervals</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Grab the load bus voltage at 5 minute intervals over the entire time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and chop out all samples within an hour of eclipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elbv_5min</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;elbv&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;5min&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elbv_5min</span><span class="o">.</span><span class="n">remove_intervals</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">eclipses</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">3600</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plot histogram of voltages, using single sample at the 5 min midpoint (not mean)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">(</span><span class="n">elbv_5min</span><span class="o">.</span><span class="n">midvals</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Overplot the post-eclipse values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">(</span><span class="n">elbv_post_eclipse</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/load_bus_voltage.png"><img alt="_images/load_bus_voltage.png" src="_images/load_bus_voltage.png" style="width: 400px;" /></a>
</div>
</div>
<div class="section" id="bad-data">
<h3>Bad data<a class="headerlink" href="#bad-data" title="Permalink to this headline">¶</a></h3>
<p>For various reasons (typically a VCDU drop) the data value associated with a particular
readout may be bad.  To handle this the engineering archive provides a boolean array
called <code class="docutils literal notranslate"><span class="pre">bads</span></code> that is <code class="docutils literal notranslate"><span class="pre">True</span></code> for bad samples.  This array corresponds to the
respective <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">vals</span></code> arrays.  To remove the bad values one can use numpy
boolean masking:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ok</span> <span class="o">=</span> <span class="o">~</span><span class="n">tephin</span><span class="o">.</span><span class="n">bads</span>  <span class="c1"># numpy mask requires the &quot;good&quot; values to be True</span>
<span class="n">vals_ok</span> <span class="o">=</span> <span class="n">tephin</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
<span class="n">times_ok</span> <span class="o">=</span> <span class="n">tephin</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
</pre></div>
</div>
<p>This is a bother to do manually so there is a built-in method that filters out
bad data points for all the MSID data arrays.  Instead just do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tephin</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>
</pre></div>
</div>
<p>In fact it can be even easier if you tell fetch to filter the bad data at the point of
retrieving the data from the archive.  The following two calls both accomplish this
task, with the first one being the preferred idiom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:007&#39;</span><span class="p">)</span>
<span class="n">tephin</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:007&#39;</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>You might wonder why fetch ever bothers to return bad data and a bad mask, but
this will become apparent later when we start using time-correlated values instead
just simple time plots.</p>
<div class="section" id="really-bad-data">
<h4>Really bad data<a class="headerlink" href="#really-bad-data" title="Permalink to this headline">¶</a></h4>
<p>Even after applying <code class="docutils literal notranslate"><span class="pre">filter_bad()</span></code> you may run across obviously bad data in
the archive (e.g. there is a single value of AORATE1 of around 2e32
in 2007).  These are not marked with bad quality in the CXC archive and are
presumably real telemetry errors.  If you run across a bad data point you can
locate and filter it out as follows (but see also <a class="reference internal" href="#filter-bad-times"><span class="std std-ref">Filtering out arbitrary time intervals</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aorate1</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;aorate1&#39;</span><span class="p">,</span> <span class="s1">&#39;2007:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2008:001&#39;</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">bad_vals_mask</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aorate1</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span>
<span class="n">aorate1</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="n">bad_vals_mask</span><span class="p">]</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="mf">2.24164635e+32</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>

<span class="n">Chandra</span><span class="o">.</span><span class="n">Time</span><span class="o">.</span><span class="n">DateTime</span><span class="p">(</span><span class="n">aorate1</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">bad_vals_mask</span><span class="p">])</span><span class="o">.</span><span class="n">date</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="n">array</span><span class="p">([</span><span class="s1">&#39;2007:310:22:10:02.951&#39;</span><span class="p">],</span>
       <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S21&#39;</span><span class="p">)</span>

<span class="n">aorate1</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">(</span><span class="n">bad_vals_mask</span><span class="p">)</span>
<span class="n">bad_vals_mask</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aorate1</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span>
<span class="n">aorate1</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="n">bad_vals_mask</span><span class="p">]</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="filtering-out-arbitrary-time-intervals">
<span id="filter-bad-times"></span><h4>Filtering out arbitrary time intervals<a class="headerlink" href="#filtering-out-arbitrary-time-intervals" title="Permalink to this headline">¶</a></h4>
<p>There are many periods of time where the spacecraft was in an anomalous state
and telemetry values may be unreliable without being marked as bad by CXC data
processing.  For example during safemode the OBC
values (AO*) may be meaningless.  The preferred way to handle this situation is
using <a class="reference internal" href="#event-intervals"><span class="std std-ref">Event interval filtering</span></a> since those intervals are always up to date.</p>
<p>However, in cases where event interval filter is not applicable, an alternative mechanism
is available to remove arbitrary times of undesired data in either a
<a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> or <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aorates</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aorate*&#39;</span><span class="p">],</span> <span class="s1">&#39;2007:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2008:001&#39;</span><span class="p">)</span>
<span class="n">aorates</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">()</span>

<span class="n">aorate1</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;aorate1&#39;</span><span class="p">,</span> <span class="s1">&#39;2007:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2008:001&#39;</span><span class="p">)</span>
<span class="n">aorates</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">()</span>
</pre></div>
</div>
<p>You can view the default bad times using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fetch</span><span class="o">.</span><span class="n">msid_bad_times</span>
</pre></div>
</div>
<p>If you want to remove a different interval of time known to have bad values you
can specify the start and stop time as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aorate1</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">(</span><span class="s1">&#39;2007:025:12:13:00&#39;</span><span class="p">,</span> <span class="s1">&#39;2007:026:09:00:00&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As expected this will remove all data from the <code class="docutils literal notranslate"><span class="pre">aorate1</span></code> MSID between the
specified times.  Multiple bad time filters can be specified at once using the
<code class="docutils literal notranslate"><span class="pre">table</span></code> parameter option for <code class="docutils literal notranslate"><span class="pre">filter_bad_times</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bad_times</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;2008:292:00:00:00 2008:297:00:00:00&#39;</span><span class="p">,</span>
             <span class="s1">&#39;2008:305:00:12:00 2008:305:00:12:03&#39;</span><span class="p">,</span>
             <span class="s1">&#39;2010:101:00:01:12 2010:101:00:01:25&#39;</span><span class="p">]</span>
<span class="n">msid</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">bad_times</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">table</span></code> parameter can also be the name of a plain text file that has two
columns (separated by whitespace) containing the start and stop times:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">msid</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s1">&#39;msid_bad_times.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Because the bad times for corrupted data don’t change it doesn’t always
make sense to always have to put these hard-coded times into every plotting or
analysis script.  Instead fetch also allows you to create a plain text file of
bad times in a simple format.  The file can include any number of bad time
interval specifications, one per line.  A bad time interval line has three
columns separated by whitespace, for instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bad times file: &quot;bad_times.dat&quot;</span>
<span class="c1"># MSID      bad_start_time  bad_stop_time</span>
<span class="n">aogbias1</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">292</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">297</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span>
<span class="n">aogbias1</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">227</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">228</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span>
<span class="n">aogbias1</span> <span class="mi">2009</span><span class="p">:</span><span class="mi">253</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="mi">2009</span><span class="p">:</span><span class="mi">254</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span>
<span class="n">aogbias2</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">292</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">297</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span>
<span class="n">aogbias2</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">227</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="mi">2008</span><span class="p">:</span><span class="mi">228</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span>
<span class="n">aogbias2</span> <span class="mi">2009</span><span class="p">:</span><span class="mi">253</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span> <span class="mi">2009</span><span class="p">:</span><span class="mi">254</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span>
</pre></div>
</div>
<p>The MSID name is not case sensitive and the time values can be in any
<code class="docutils literal notranslate"><span class="pre">DateTime</span></code> format.  Blank lines and any line starting with the # character
are ignored.  To read in this bad times file do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fetch</span><span class="o">.</span><span class="n">read_bad_times</span><span class="p">(</span><span class="s1">&#39;bad_times.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once you’ve done this you can filter out all those bad times with a single method of
the MSID object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aorate1</span><span class="o">.</span><span class="n">filter_bad_times</span><span class="p">()</span>
</pre></div>
</div>
<p>In this case no start or stop time was supplied and the routine instead knows
to use the internal registry of bad times defined by MSID.  Finally, as if this
wasn’t easy enough, there is a global list of bad times that is always read
when the fetch module is loaded.  If you come across an interval of time that
can always be filtered by all users of fetch then send an email to Tom Aldcroft
with the interval and MSID and that will be added to the global registry.
After that there will be no need to explicitly run the
<code class="docutils literal notranslate"><span class="pre">fetch.read_bad_times(filename)</span></code> command to exclude that interval.</p>
</div>
<div class="section" id="copy-versus-in-place">
<h4>Copy versus in-place<a class="headerlink" href="#copy-versus-in-place" title="Permalink to this headline">¶</a></h4>
<p>All of the data filter methods shown here take an optional <code class="docutils literal notranslate"><span class="pre">copy</span></code> argument.  By default
this is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> so that the filtering is done in-place, as shown in the previous
examples.  However, if <code class="docutils literal notranslate"><span class="pre">copy=True</span></code> then a new copy of the MSID object is used for the
data filtering and this copy is returned.  In both examples below the original MSID object
will be left untouched:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:002&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aorate2_manvrs</span> <span class="o">=</span> <span class="n">aorate2</span><span class="o">.</span><span class="n">select_intervals</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">manvrs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aogbias1</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;aogbias1&#39;</span><span class="p">,</span> <span class="s1">&#39;2008:291&#39;</span><span class="p">,</span> <span class="s1">&#39;2008:298&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aogbias1_good</span> <span class="o">=</span> <span class="n">aogbias1</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">copy</span></code> argument in filter methods, <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> and <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a>
objects have a <code class="docutils literal notranslate"><span class="pre">copy()</span></code> method to explicitly make an independent copy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aogbias1_copy</span> <span class="o">=</span> <span class="n">aogbias1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">aogbias1</span><span class="o">.</span><span class="n">vals</span> <span class="o">==</span> <span class="n">aogbias1_copy</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>  <span class="c1"># Are the values identical?</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aogbias1</span><span class="o">.</span><span class="n">vals</span> <span class="ow">is</span> <span class="n">aogbias1_copy</span><span class="o">.</span><span class="n">vals</span>  <span class="c1"># Are the values arrays the same object?</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="five-minute-and-daily-stats">
<h2>Five minute and daily stats<a class="headerlink" href="#five-minute-and-daily-stats" title="Permalink to this headline">¶</a></h2>
<p>The engineering telemetry archive also hosts tables of telemetry statistics
computed over 5 minute and daily intervals.  To be more precise, the intervals
are 328 seconds (10 major frames) and 86400 seconds.  The daily intervals are
not <em>exactly</em> lined up with the midnight boundary but are within a couple of minutes.
These data are accessed by specifying
<code class="docutils literal notranslate"><span class="pre">stat=&lt;interval&gt;</span></code> in the <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tephin_5min</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;5min&#39;</span><span class="p">)</span>
<span class="n">tephin_daily</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:001&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;daily&#39;</span><span class="p">)</span>
<span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">clf</span><span class="p">()</span>
<span class="n">plot_cxctime</span><span class="p">(</span><span class="n">tephin_daily</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tephin_daily</span><span class="o">.</span><span class="n">mins</span><span class="p">,</span> <span class="s1">&#39;-b&#39;</span><span class="p">)</span>
<span class="n">plot_cxctime</span><span class="p">(</span><span class="n">tephin_daily</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tephin_daily</span><span class="o">.</span><span class="n">maxes</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">)</span>
<span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">clf</span><span class="p">()</span>
<span class="n">plot_cxctime</span><span class="p">(</span><span class="n">tephin_5min</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tephin_5min</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="s1">&#39;-b&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/tephin_daily.png" src="_images/tephin_daily.png" />
<p>Notice that we did not supply a stop time which means to return values up to the last
available data in the archive.  The start time, however, is always required.</p>
<p>The MSID object returned for a telemetry statistics query has a number of array
attributes, depending on the statistic and the MSID data type.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 24%" />
<col style="width: 22%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>5min</p></th>
<th class="head"><p>daily</p></th>
<th class="head"><p>Supported types</p></th>
<th class="head"><p>Column type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>times</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float,string</p></td>
<td><p>float</p></td>
<td><p>Time at midpoint</p></td>
</tr>
<tr class="row-odd"><td><p>indexes</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float,string</p></td>
<td><p>int</p></td>
<td><p>Interval index</p></td>
</tr>
<tr class="row-even"><td><p>samples</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float,string</p></td>
<td><p>int16</p></td>
<td><p>Number of samples</p></td>
</tr>
<tr class="row-odd"><td><p>midvals</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float,string</p></td>
<td><p>int,float,string</p></td>
<td><p>Sample at midpoint</p></td>
</tr>
<tr class="row-even"><td><p>vals</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>int,float</p></td>
<td><p>Mean</p></td>
</tr>
<tr class="row-odd"><td><p>mins</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>int,float</p></td>
<td><p>Minimum</p></td>
</tr>
<tr class="row-even"><td><p>maxes</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>int,float</p></td>
<td><p>Maximum</p></td>
</tr>
<tr class="row-odd"><td><p>means</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>Mean</p></td>
</tr>
<tr class="row-even"><td><p>stds</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>Standard deviation</p></td>
</tr>
<tr class="row-odd"><td><p>p01s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>1% percentile</p></td>
</tr>
<tr class="row-even"><td><p>p05s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>5% percentile</p></td>
</tr>
<tr class="row-odd"><td><p>p16s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>16% percentile</p></td>
</tr>
<tr class="row-even"><td><p>p50s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>50% percentile</p></td>
</tr>
<tr class="row-odd"><td><p>p84s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>84% percentile</p></td>
</tr>
<tr class="row-even"><td><p>p95s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>95% percentile</p></td>
</tr>
<tr class="row-odd"><td><p>p99s</p></td>
<td></td>
<td><p>x</p></td>
<td><p>int,float</p></td>
<td><p>float</p></td>
<td><p>99% percentile</p></td>
</tr>
</tbody>
</table>
<p>Note: the inadvertent use of int16 for the daily stat <code class="docutils literal notranslate"><span class="pre">samples</span></code> column means
that it rolls over at 32767.  This column should not be trusted at this time.</p>
<p>As an example a daily statistics query for the PCAD mode <code class="docutils literal notranslate"><span class="pre">AOPCADMD</span></code>
(<code class="docutils literal notranslate"><span class="pre">NPNT</span></code>, <code class="docutils literal notranslate"><span class="pre">NMAN</span></code>, etc) yields an object with only the <code class="docutils literal notranslate"><span class="pre">times</span></code>,
<code class="docutils literal notranslate"><span class="pre">indexes</span></code>, <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and <code class="docutils literal notranslate"><span class="pre">vals</span></code> arrays.  For these state MSIDs
there is no really useful meaning for the other statistics.</p>
<p>Telemetry statistics are a little different than the full-resolution data in
that they do not have an associated bad values mask.  Instead if there are not
at least 3 good samples within an interval then no record for that interval
will exist.</p>
</div>
<div class="section" id="msid-sets">
<h2>MSID sets<a class="headerlink" href="#msid-sets" title="Permalink to this headline">¶</a></h2>
<p>Frequently one wants to fetch a set of MSIDs over the same time range.  This is
easily accomplished:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rates</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aorate1&#39;</span><span class="p">,</span> <span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;aorate3&#39;</span><span class="p">],</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:002&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned <code class="docutils literal notranslate"><span class="pre">rates</span></code> object is like a python dictionary (hash) object with
a couple extra methods.  Indexing the object by the MSID name gives the
usual <code class="docutils literal notranslate"><span class="pre">fetch.MSID</span></code> object that we’ve been using up to this point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span><span class="p">()</span>
<span class="n">plot_cxctime</span><span class="p">(</span><span class="n">rates</span><span class="p">[</span><span class="s1">&#39;aorate1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">rates</span><span class="p">[</span><span class="s1">&#39;aorate1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>
</pre></div>
</div>
<p>You might wonder what’s special about an <code class="docutils literal notranslate"><span class="pre">MSIDset</span></code>, after all the actual code
that creates an <code class="docutils literal notranslate"><span class="pre">MSIDset</span></code> is very simple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="p">:</span>
    <span class="bp">self</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSID</span><span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="n">stat</span><span class="p">)</span>

<span class="k">if</span> <span class="n">filter_bad</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>
</pre></div>
</div>
<p>The answer lies in the additional methods that let you manipulate the MSIDs as a set and
enforce concordance between the MSIDs in the face of different bad values and/or
different sampling.</p>
<p>Say you want to calculate the spacecraft rates directly from telemetered gyro
count values instead of relying on OBC rates.  To do this you need to have
valid data for all 4 gyro channels at identical times.  In this case we know that
the gyro count MSIDs AOGYRCT&lt;N&gt; all come at the same rate so the only issue is with
bad values.  Taking advantage <a class="reference internal" href="#msid-globs">MSID globs</a> to choose <code class="docutils literal notranslate"><span class="pre">AOGYRCT1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4</span></code> we can write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cts</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aogyrct?&#39;</span><span class="p">],</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:002&#39;</span><span class="p">)</span>
<span class="n">cts</span><span class="o">.</span><span class="n">filter_bad</span><span class="p">()</span>
<span class="c1"># OR equivalently</span>
<span class="n">cts</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aogyrct?&#39;</span><span class="p">],</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:002&#39;</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we know that <code class="docutils literal notranslate"><span class="pre">cts['aogyrct1']</span></code> is exactly lined up with
<code class="docutils literal notranslate"><span class="pre">cts['aogyrct2']</span></code> and so forth.  Any bad value among the 4 MSIDs will filter
out the all the values for that time stamp.  It’s important to note that the
resulting data may well have time “gaps” where bad values were filtered.  In this case
the time delta between samples won’t always be 0.25625 seconds.</p>
<p>How do you know if your favorite MSIDs are always sampled at the same rate in
the Ska engineering archive?  Apart from certain sets of MSIDs that are obvious
(like the gyro counts), here is where things get a little complicated and a
digression is needed.</p>
<p>The engineering archive is derived from CXC level-0 engineering telemetry
decom.  This processing divides the all the engineering MSIDs into groups based
on subsystem (ACIS, CCDM, EPHIN, EPS, HRC, MISC, OBC, PCAD, PROP, SIM, SMS,
TEL, THM) and further divides by sampling rate (e.g. ACIS2ENG, ACIS3ENG,
ACIS4ENG).  In all there about 80 “content-types” for engineering telemetry.
All MSIDs within a content type are guaranteed to come out of CXC L0 decom with
the same time-stamps, though of course the bad value masks can be different.
Thus from the perspective of the Ska engineering archive two MSIDs are sure to
have the same sampling (time-stamps) if and only if they have have the same CXC
content type.  In order to know whether the <code class="docutils literal notranslate"><span class="pre">MSIDset.filter_bad()</span></code> function
will apply a common bad values filter to a set of MSIDs you need to inspect the
content type as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">msids</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aorate1&#39;</span><span class="p">,</span> <span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;aogyrct1&#39;</span><span class="p">,</span> <span class="s1">&#39;aogyrct2&#39;</span><span class="p">],</span> <span class="s1">&#39;2009:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:002&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">msid</span> <span class="ow">in</span> <span class="n">msids</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="nb">print</span> <span class="n">msid</span><span class="o">.</span><span class="n">msid</span><span class="p">,</span> <span class="n">msid</span><span class="o">.</span><span class="n">content</span>
</pre></div>
</div>
<p>In this case if we apply the <code class="docutils literal notranslate"><span class="pre">filter_bad()</span></code> method then <code class="docutils literal notranslate"><span class="pre">aorate1</span></code> and
<code class="docutils literal notranslate"><span class="pre">aorate2</span></code> will be grouped separately from <code class="docutils literal notranslate"><span class="pre">aogyrct1</span></code> and <code class="docutils literal notranslate"><span class="pre">aogyrct2</span></code>.  In
most cases this is probably the right thing, but there is another
hammer we can use if not.</p>
<p>Pretend we want to look for a correlation between gyro channel 1 rate and star centroid
rates in Y during an observation.  We get new gyro counts every 0.25625 sec and a
new centroid value every 2.05 sec.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">msids</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aoacyan3&#39;</span><span class="p">,</span> <span class="s1">&#39;aogyrct1&#39;</span><span class="p">],</span> <span class="s1">&#39;2009:246:08:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;2009:246:18:00:00&#39;</span><span class="p">)</span>
<span class="n">msids</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="mf">2.05</span><span class="p">)</span>
<span class="n">aca_dy</span> <span class="o">=</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aoacyan3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aoacyan3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">aca_dt</span> <span class="o">=</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aoacyan3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aoacyan3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">aca_rate</span> <span class="o">=</span> <span class="n">aca_dy</span> <span class="o">/</span> <span class="n">aca_dt</span>
<span class="n">gyr_dct1</span> <span class="o">=</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">gyr_dt</span> <span class="o">=</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">msids</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">gyr_rate</span> <span class="o">=</span> <span class="n">gyr_dct1</span> <span class="o">/</span> <span class="n">gyr_dt</span> <span class="o">*</span> <span class="mf">0.02</span>
<span class="n">clf</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">aca_rate</span><span class="p">,</span> <span class="n">gyr_rate</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/aca_gyro_rates.png" src="_images/aca_gyro_rates.png" />
<div class="section" id="interpolation">
<h3>Interpolation<a class="headerlink" href="#interpolation" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset.interpolate" title="Ska.engarchive.fetch.MSIDset.interpolate"><code class="xref py py-func docutils literal notranslate"><span class="pre">interpolate()</span></code></a> method allows for resampling all the MSIDs in a
set onto a single common time sequence.  This is done by performing
nearest-neighbor interpolation of all MSID values.  By default the update
is done in-place, but if called with <code class="docutils literal notranslate"><span class="pre">copy=True</span></code> then a new <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a>
is returned and the original is not modified (see <a class="reference internal" href="#copy-versus-in-place">Copy versus in-place</a>).</p>
<div class="section" id="times">
<h4>Times<a class="headerlink" href="#times" title="Permalink to this headline">¶</a></h4>
<p>The time sequence steps uniformly by <code class="docutils literal notranslate"><span class="pre">dt</span></code> seconds starting at the
<code class="docutils literal notranslate"><span class="pre">start</span></code> time and ending at the <code class="docutils literal notranslate"><span class="pre">stop</span></code> time.  If not provided the
times default to the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> times for the MSID set.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">times</span></code> is provided then this gets used instead of the default linear
progression from <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
<p>For each MSID in the set the <code class="docutils literal notranslate"><span class="pre">times</span></code> attribute is set to the common
time sequence.  In addition a new attribute <code class="docutils literal notranslate"><span class="pre">times0</span></code> is defined that
stores the nearest neighbor interpolated time, providing the <em>original</em>
timestamps of each new interpolated value for that MSID.</p>
</div>
<div class="section" id="filtering-and-bad-values">
<h4>Filtering and bad values<a class="headerlink" href="#filtering-and-bad-values" title="Permalink to this headline">¶</a></h4>
<p>A key issue in interpolation is the handling of bad (missing) telemetry
values.  There are two parameters that control the behavior, <code class="docutils literal notranslate"><span class="pre">filter_bad</span></code>
and <code class="docutils literal notranslate"><span class="pre">bad_union</span></code>.</p>
<p>The plots and discussion below illustrate the effect of <code class="docutils literal notranslate"><span class="pre">filter_bad</span></code> and
<code class="docutils literal notranslate"><span class="pre">bad_union</span></code> for a synthetic dataset consisting of two MSIDs which are sampled
at 1.025 seconds (red) and 4.1 seconds (blue).  The red values are increasing
linearly while the blue ones are decreasing linearly.  Each MSID has a single
bad point which is marked with a black cross.  The first plot below is the input
un-interpolated data:</p>
<a class="reference internal image-reference" href="_images/interpolate_input.png"><img alt="_images/interpolate_input.png" src="_images/interpolate_input.png" style="width: 400px;" /></a>
<p>If <code class="docutils literal notranslate"><span class="pre">filter_bad</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (which is the default) then bad values are
filtered from the interpolated MSID set.  There are two strategies for doing
this:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">bad_union</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
<p>Remove the bad values in each MSID <em>prior</em> to interpolating the set to a
common time series.  Since each MSID has bad data filtered individually
before interpolation, the subsequent nearest neighbor interpolation only
finds “good” data and there are no gaps in the output.  This strategy is done
when <code class="docutils literal notranslate"><span class="pre">bad_union</span> <span class="pre">=</span> <span class="pre">False</span></code>, which is the default setting.  The results are
shown below:</p>
<a class="reference internal image-reference" href="_images/interpolate_True_False.png"><img alt="_images/interpolate_True_False.png" src="_images/interpolate_True_False.png" style="width: 400px;" /></a>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bad_union</span> <span class="pre">=</span> <span class="pre">True</span></code></p></li>
</ol>
<blockquote>
<div><p>Remove the bad values <em>after</em> interpolating the set to a common time series.
This marks every MSID in the set as bad at the interpolated time if <em>any</em> of
them are bad at that time.  This stricter version is required when it is
important that the MSIDs be truly correlated in time.  For instance this is
needed for attitude quaternions since all four values must be from the exact
same telemetry sample.  If you are not sure, this is the safer option because
gaps in the input data are reflected as gaps in the output.</p>
<a class="reference internal image-reference" href="_images/interpolate_True_True.png"><img alt="_images/interpolate_True_True.png" src="_images/interpolate_True_True.png" style="width: 400px;" /></a>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">filter_bad</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> then bad values and the associated <code class="docutils literal notranslate"><span class="pre">bads</span></code>
attribute are left in the MSID objects of the interpolated <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a>.  The
behaviors are:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">bad_union</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
<p>Bad values represent the bad status of each MSID individually at the
interpolated time stamps.</p>
<a class="reference internal image-reference" href="_images/interpolate_False_False.png"><img alt="_images/interpolate_False_False.png" src="_images/interpolate_False_False.png" style="width: 400px;" /></a>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bad_union</span> <span class="pre">=</span> <span class="pre">True</span></code></p>
<p>Bad values represent the union of bad status for all the MSIDs at the
interpolated time stamps.  Notice how the <code class="docutils literal notranslate"><span class="pre">filter_bad</span> <span class="pre">=</span> <span class="pre">True</span></code> and
<code class="docutils literal notranslate"><span class="pre">bad_union</span> <span class="pre">=</span> <span class="pre">True</span></code> case above is exactly like this one but with the
crossed-out points removed.</p>
<a class="reference internal image-reference" href="_images/interpolate_False_True.png"><img alt="_images/interpolate_False_True.png" src="_images/interpolate_False_True.png" style="width: 400px;" /></a>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="unit-systems">
<h2>Unit systems<a class="headerlink" href="#unit-systems" title="Permalink to this headline">¶</a></h2>
<p>Within <code class="docutils literal notranslate"><span class="pre">fetch</span></code> it is possible to select a different system of physical
units for the retrieved telemetry.  Internally the engineering archive
stores values in the FITS format standard units as used by the CXC archive.
This is essentially the MKS system and features all temperatures in Kelvins
(not the most convenient).</p>
<p>In addition to the CXC unit system one can select “science” units or
“engineering” units:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>System</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cxc</p></td>
<td><p>FITS standard units used in CXC archive files (basically MKS)</p></td>
</tr>
<tr class="row-odd"><td><p>sci</p></td>
<td><p>Same as “cxc” but with temperatures in degC instead of Kelvins</p></td>
</tr>
<tr class="row-even"><td><p>eng</p></td>
<td><p>OCC engineering units (TDB P009, e.g. degF, ft-lb-sec, PSI)</p></td>
</tr>
</tbody>
</table>
<p>The simplest way to select a different unit system is to alter the
canonical command for importing the <code class="docutils literal notranslate"><span class="pre">fetch</span></code> module.  To always use OCC
engineering units use the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Ska.engarchive</span> <span class="kn">import</span> <span class="n">fetch_eng</span> <span class="k">as</span> <span class="n">fetch</span>
</pre></div>
</div>
<p>This uses a special Python syntax to import the <code class="docutils literal notranslate"><span class="pre">fetch_eng</span></code> module
but then refer to it as <code class="docutils literal notranslate"><span class="pre">fetch</span></code>.  In this way there is no need to
change existing codes (except one line) or habits.  To always use “science”
units use the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Ska.engarchive</span> <span class="kn">import</span> <span class="n">fetch_sci</span> <span class="k">as</span> <span class="n">fetch</span>
</pre></div>
</div>
<div class="section" id="mixing-units">
<h3>Mixing units<a class="headerlink" href="#mixing-units" title="Permalink to this headline">¶</a></h3>
<p>Beginning with version 0.18 of the engineering archive it is possible to
reliably use the import mechanism to select different unit systems within the
same script or Python process.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Ska.engarchive.fetch</span> <span class="k">as</span> <span class="nn">fetch_cxc</span>  <span class="c1"># CXC units</span>
<span class="kn">import</span> <span class="nn">Ska.engarchive.fetch_eng</span> <span class="k">as</span> <span class="nn">fetch_eng</span>
<span class="kn">import</span> <span class="nn">Ska.engarchive.fetch_sci</span> <span class="k">as</span> <span class="nn">fetch_sci</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">fetch_cxc</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:002&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">unit</span>  <span class="c1"># prints &quot;K&quot;</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">fetch_eng</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:002&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">t2</span><span class="o">.</span><span class="n">unit</span>  <span class="c1"># prints &quot;DEGF&quot;</span>

<span class="n">t3</span> <span class="o">=</span> <span class="n">fetch_sci</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:002&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">t3</span><span class="o">.</span><span class="n">unit</span>  <span class="c1"># prints &quot;DEGC&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="msid-globs">
<h2>MSID globs<a class="headerlink" href="#msid-globs" title="Permalink to this headline">¶</a></h2>
<p>Each input <code class="docutils literal notranslate"><span class="pre">msid</span></code> for <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> or <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a> is
case-insensitive and can include the linux file “glob” patterns “*”, “?”, and
“[&lt;characters&gt;]”.  See the <a class="reference external" href="http://docs.python.org/library/fnmatch.html">fnmatch</a> documentation for more details.</p>
<p>In the case of fetching a single MSID with fetch.MSID, the pattern must match
exactly one MSID.  The following are valid examples of the input MSID glob and
the matched MSID:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;orb*1*_x&quot;</span><span class="p">:</span> <span class="n">ORBITEPHEM1_X</span>
<span class="s2">&quot;*pcadmd&quot;</span><span class="p">:</span> <span class="n">AOPCADMD</span>
</pre></div>
</div>
<p>The real power of globbing is for <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a> where you can easily
choose a few related MSIDs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;orb*1*_?&quot;</span><span class="p">:</span> <span class="n">ORBITEPHEM1_X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">Z</span>
<span class="s2">&quot;orb*1*_[xyz]&quot;</span><span class="p">:</span> <span class="n">ORBITEPHEM1_X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">Z</span>
<span class="s2">&quot;aoattqt[123]&quot;</span><span class="p">:</span> <span class="n">AOATTQT1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">and</span> <span class="mi">3</span>
<span class="s2">&quot;aoattqt*&quot;</span><span class="p">:</span> <span class="n">AOATTQT1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">and</span> <span class="mi">4</span>

<span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;orb*1*_[xyz]&#39;</span><span class="p">,</span> <span class="s1">&#39;aoattqt*&#39;</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.msid_glob" title="Ska.engarchive.fetch.msid_glob"><code class="xref py py-func docutils literal notranslate"><span class="pre">msid_glob()</span></code></a> method will show you exactly what
matches a given <code class="docutils literal notranslate"><span class="pre">msid</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">msid_glob</span><span class="p">(</span><span class="s1">&#39;orb*1*_?&#39;</span><span class="p">)</span>
<span class="go">([&#39;orbitephem1_x&#39;, &#39;orbitephem1_y&#39;, &#39;orbitephem1_z&#39;],</span>
<span class="go"> [&#39;ORBITEPHEM1_X&#39;, &#39;ORBITEPHEM1_Y&#39;, &#39;ORBITEPHEM1_Z&#39;])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">msid_glob</span><span class="p">(</span><span class="s1">&#39;dpa_power&#39;</span><span class="p">)</span>
<span class="go">([&#39;dpa_power&#39;], [&#39;DP_DPA_POWER&#39;])</span>
</pre></div>
</div>
<p>If the MSID glob matches more than 10 MSIDs then an exception is raised to
prevent accidentally trying to fetch too many MSIDs (e.g. if you provided “AO*”
as an input).  This limit can be changed by setting the <code class="docutils literal notranslate"><span class="pre">MAX_GLOB_MATCHES</span></code>
module attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fetch</span><span class="o">.</span><span class="n">MAX_GLOB_MATCHES</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>
</div>
<p>Finally, for derived parameters the initial <code class="docutils literal notranslate"><span class="pre">DP_</span></code> is optional:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;dpa_pow*&quot;</span><span class="p">:</span> <span class="n">DP_DPA_POWER</span>
<span class="s2">&quot;roll&quot;</span><span class="p">:</span> <span class="n">DP_ROLL</span>
</pre></div>
</div>
</div>
<div class="section" id="state-valued-msids">
<h2>State-valued MSIDs<a class="headerlink" href="#state-valued-msids" title="Permalink to this headline">¶</a></h2>
<p>MSIDs that are state-valued such as <code class="docutils literal notranslate"><span class="pre">AOPCADMD</span></code> or <code class="docutils literal notranslate"><span class="pre">AOECLIPS</span></code> have the full
state code values stored in the <code class="docutils literal notranslate"><span class="pre">vals</span></code> attribute.  The raw count values can
be accessed with the <code class="docutils literal notranslate"><span class="pre">raw_vals</span></code> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aopcadmd&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:185&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:195&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;daily&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">vals</span>
<span class="go">array([&#39;NMAN&#39;, &#39;NMAN&#39;, &#39;STBY&#39;, &#39;STBY&#39;, &#39;STBY&#39;, &#39;NSUN&#39;, &#39;NPNT&#39;, &#39;NPNT&#39;,</span>
<span class="go">&#39;NPNT&#39;, &#39;NPNT&#39;],</span>
<span class="go">dtype=&#39;|S4&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">raw_vals</span>
<span class="go">array([2, 2, 0, 0, 0, 3, 1, 1, 1, 1], dtype=int8)</span>
</pre></div>
</div>
<p>This is handy for plotting or other analysis that benefits from a numeric
representation of the values.  The mapping of raw values to state code is available
in the <code class="docutils literal notranslate"><span class="pre">state_codes</span></code> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">state_codes</span>
<span class="go">[(0, &#39;STBY&#39;),</span>
<span class="go"> (1, &#39;NPNT&#39;),</span>
<span class="go"> (2, &#39;NMAN&#39;),</span>
<span class="go"> (3, &#39;NSUN&#39;),</span>
<span class="go"> (4, &#39;PWRF&#39;),</span>
<span class="go"> (5, &#39;RMAN&#39;),</span>
<span class="go"> (6, &#39;NULL&#39;)]</span>
</pre></div>
</div>
<div class="section" id="state-value-counts">
<h3>State value counts<a class="headerlink" href="#state-value-counts" title="Permalink to this headline">¶</a></h3>
<p>For state-valued MSIDs, the 5-minute and daily statistics include attributes that provide
the count of samples within the interval for each possible state.  The attribute will be
named <code class="docutils literal notranslate"><span class="pre">n_&lt;STATE&gt;s</span></code>, for instance <code class="docutils literal notranslate"><span class="pre">n_NMANs</span></code> for <code class="docutils literal notranslate"><span class="pre">AOPCADMD</span></code>.</p>
<p>These counts are useful in at least a couple of different ways.  First, one can determine
the duty cycle for an ON/OFF bi-level for mission trending:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;4ohtrz10&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:010&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;daily&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">n_ONs</span>
<span class="go">array([3674, 3626, 3624, 3615, 3599, 3686, 3654, 3640], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">n_OFFs</span>
<span class="go">array([6852, 6910, 6913, 6922, 6937, 6850, 6881, 6895], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">n_ONs</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dat</span><span class="o">.</span><span class="n">samples</span>
<span class="go">array([ 0.34975323,  0.34925005,  0.34415338,  0.34393091,  0.34307678,</span>
<span class="go">        0.34159074,  0.34984814,  0.34684385,  0.34551495])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;4ohtrz10&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2017:001&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;daily&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">duty_cycle</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">n_ONs</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dat</span><span class="o">.</span><span class="n">samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_cxctime</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">duty_cycle</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;ON duty cycle for 4OHTRZ10&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/state_bins_4ohtrz10.png" src="_images/state_bins_4ohtrz10.png" />
<p>Second, one can use the state counts to very quickly look for rare occurrences of an MSID
in a particular state.  As an example we can easily find every time that PCAD reported
being in bright star hold (<code class="docutils literal notranslate"><span class="pre">AOACASEQ</span> <span class="pre">==</span> <span class="pre">'BRIT'</span></code>).  This could occur due to an
autonomous safing action or as part of a realtime recovery activity.  In any case
searching the full-resolution telemetry is slow and memory intensive, but doing this
via the daily state code counts is a snap:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aoacaseq&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:001&#39;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;daily&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ok</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">n_BRITs</span> <span class="o">&gt;</span> <span class="mi">10</span>  <span class="c1"># Require at least 10 BRIT samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">d</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span><span class="o">.</span><span class="n">date</span><span class="p">])</span>
<span class="go">[&#39;2000:049&#39;, &#39;2001:111&#39;, &#39;2001:112&#39;, &#39;2001:265&#39;, &#39;2002:024&#39;, &#39;2003:200&#39;, &#39;2004:200&#39;,</span>
<span class="go"> &#39;2004:208&#39;, &#39;2004:213&#39;, &#39;2004:315&#39;, &#39;2004:316&#39;, &#39;2008:225&#39;, &#39;2008:226&#39;, &#39;2008:227&#39;,</span>
<span class="go"> &#39;2008:294&#39;, &#39;2010:151&#39;, &#39;2011:190&#39;, &#39;2011:192&#39;, &#39;2011:299&#39;, &#39;2011:300&#39;, &#39;2012:151&#39;,</span>
<span class="go"> &#39;2014:207&#39;, &#39;2015:007&#39;, &#39;2015:264&#39;, &#39;2015:265&#39;, &#39;2016:064&#39;, &#39;2016:234&#39;, &#39;2016:324&#39;,</span>
<span class="go"> &#39;2016:325&#39;]</span>
</pre></div>
</div>
<p>One could then drill down on these dates using 5-minute or full-resolution telemetry.</p>
</div>
</div>
<div class="section" id="telemetry-database">
<h2>Telemetry database<a class="headerlink" href="#telemetry-database" title="Permalink to this headline">¶</a></h2>
<p>With an <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSID" title="Ska.engarchive.fetch.MSID"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSID()</span></code></a> object you can directly access all the information
in the Chandra Telemetry Database which relates to that MSID.  This is
done through the
<a class="reference external" href="http://cxc.harvard.edu/mta/ASPECT/tool_doc/pydocs/Ska.tdb.html">Ska.tdb</a>
module.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aopcadmd&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:187&#39;</span><span class="p">,</span> <span class="s1">&#39;2011:190&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">tdb</span>  <span class="c1"># Top level summary of TDB info for AOPCADMD</span>
<span class="go">&lt;MsidView msid=&quot;AOPCADMD&quot; technical_name=&quot;PCAD MODE&quot;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">tdb</span><span class="o">.</span><span class="n">Tsc</span>  <span class="c1"># full state codes table</span>
<span class="go">rec.array([(&#39;AOPCADMD&#39;, 1, 1, 0, 0, &#39;STBY&#39;), (&#39;AOPCADMD&#39;, 1, 7, 6, 6, &#39;NULL&#39;),</span>
<span class="go">           (&#39;AOPCADMD&#39;, 1, 6, 5, 5, &#39;RMAN&#39;), (&#39;AOPCADMD&#39;, 1, 5, 4, 4, &#39;PWRF&#39;),</span>
<span class="go">           (&#39;AOPCADMD&#39;, 1, 4, 3, 3, &#39;NSUN&#39;), (&#39;AOPCADMD&#39;, 1, 2, 1, 1, &#39;NPNT&#39;),</span>
<span class="go">           (&#39;AOPCADMD&#39;, 1, 3, 2, 2, &#39;NMAN&#39;)],</span>
<span class="go">          dtype=[(&#39;MSID&#39;, &#39;|S15&#39;), (&#39;CALIBRATION_SET_NUM&#39;, &#39;&lt;i8&#39;),</span>
<span class="go">                 (&#39;SEQUENCE_NUM&#39;, &#39;&lt;i8&#39;), (&#39;LOW_RAW_COUNT&#39;, &#39;&lt;i8&#39;),</span>
<span class="go">                 (&#39;HIGH_RAW_COUNT&#39;, &#39;&lt;i8&#39;), (&#39;STATE_CODE&#39;, &#39;|S4&#39;)])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">tdb</span><span class="o">.</span><span class="n">Tsc</span><span class="p">[</span><span class="s1">&#39;STATE_CODE&#39;</span><span class="p">]</span>  <span class="c1"># STATE_CODE column</span>
<span class="go">rec.array([&#39;STBY&#39;, &#39;NULL&#39;, &#39;RMAN&#39;, &#39;PWRF&#39;, &#39;NSUN&#39;, &#39;NPNT&#39;, &#39;NMAN&#39;],</span>
<span class="go">          dtype=&#39;|S4&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">tdb</span><span class="o">.</span><span class="n">technical_name</span>
<span class="go">&#39;PCAD MODE&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">tdb</span><span class="o">.</span><span class="n">description</span>
<span class="go">&#39;LR/15/SD/10 PCAD_MODE&#39;</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">tdb</span></code> attribute is equivalent to <code class="docutils literal notranslate"><span class="pre">Ska.tdb.msids[MSID]</span></code>,
so refer to the
<a class="reference external" href="http://cxc.harvard.edu/mta/ASPECT/tool_doc/pydocs/Ska.tdb.html">Ska.tdb</a>
documentation for further information.</p>
</div>
<div class="section" id="maude-telemetry-server">
<h2>MAUDE telemetry server<a class="headerlink" href="#maude-telemetry-server" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">fetch</span></code> module provides the capability to choose the source of telemetry data used
in queries.  The historical (and current default) source of telemetry data consists of a
collection of HDF5 files that are constructed and updated daily using CXC level-0
engineering telemetry decom products.  This has the bulk of commonly used telemetry but
typically has a latency of 2-3 days.</p>
<p>In order to fill this gap an interface to the <a class="reference external" href="http://occweb.cfa.harvard.edu/twiki/Software/MaudeSupport">MAUDE telemetry server</a> is also available.</p>
<p>The key differences between the CXC and MAUDE telemetry data sources are:</p>
<ul class="simple">
<li><p>CXC includes <a class="reference external" href="../pseudo_msids.html">pseudo-MSIDs</a> such as ephemeris data, ACIS and HRC
housekeeping, and derived parameters like the pitch and off-nominal roll angle.</p></li>
<li><p>CXC has a latency of 2-3 days vs. hours for MAUDE back-orbit telemetry.</p></li>
<li><p>During a realtime support MAUDE provides near-realime telemetry.</p></li>
<li><p>As of MAUDE 0.7.2 there is no support for 5-minute and daily stats (coming in 0.7.3).</p></li>
<li><p>CXC has about 6800 MSIDs while MAUDE has around 11350.  At least some of the MSIDs that
are only in MAUDE are somewhat obscure ones like <code class="docutils literal notranslate"><span class="pre">ACIMG1D1</span></code> (PEA1 PIXEL D1 DATA IMAGE
1) which the CXC decoms into higher-level products.</p></li>
<li><p>CXC is optimized for large bulk queries using direct disk access.  It is limited only by
system memory (gigabytes) and <strong>always returns all available data points</strong>.</p></li>
<li><p>MAUDE is optimized for smaller, more frequent queries and uses a secure web server to
provide data.  It has limits on both the number of returned data values (around 100k)
and the total number of bytes in the data (around 1.6 Mb).  <strong>MAUDE will sub-sample
the data as necessary to fit in the data limits (see below for example)</strong>.</p></li>
</ul>
<div class="section" id="basic-usage">
<h3>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h3>
<p>Once you have followed the steps to <a class="reference internal" href="#setup-for-maude-authentication">Setup for MAUDE authentication</a>, you can access
the MAUDE data.</p>
<p>The source of data for fetch queries is controlled by the module-level <code class="docutils literal notranslate"><span class="pre">fetch.data_source</span></code>
configuration object.  You can first view the current data source with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span>
<span class="go">(&#39;cxc&#39;,)</span>
</pre></div>
</div>
<p>This shows that the current source of data is the CXC files.  You can change to MAUDE as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;maude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span>
<span class="go">(&#39;maude&#39;,)</span>
</pre></div>
</div>
<p>Now if you execute a query MAUDE will be used.  There is not any obvious difference from
the user perspective and the returned <code class="docutils literal notranslate"><span class="pre">Msid</span></code> object looks and behaves exactly as if you
had queried from the CXC data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2015:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2015:002&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The most direct way to be sure of the actual data source is to look at the <code class="docutils literal notranslate"><span class="pre">data_source</span></code>
attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data_source</span>
<span class="go">{&#39;maude&#39;: {&#39;flags&#39;: {&#39;subset&#39;: False, &#39;tolerance&#39;: False},</span>
<span class="go">           &#39;start&#39;: &#39;2015:001:12:00:15.037&#39;,</span>
<span class="go">           &#39;stop&#39;: &#39;2015:002:11:59:37.452&#39;}}</span>
</pre></div>
</div>
<p>This shows the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> time for data values that were returned
by the MAUDE server.  In addition two status flags are returned.</p>
<p><strong>Data subsets</strong></p>
<p>For the purposes here, the important flag is <code class="docutils literal notranslate"><span class="pre">subset</span></code>.  As mentioned above, the MAUDE
server will not return more than around 100k data values in a single query.  When a query
would return more than this number of values then the server automatically subsamples the
data to return no more than 100k points.  This is done in a clever way such that it
reproduces what a plot of the fully-sampled dataset would look like at screen resolution.
Nevertheless one should pay attention to the <code class="docutils literal notranslate"><span class="pre">subset</span></code> flag, particularly in cases where
subsampling could affect analysis results.  One example is examinine attitude quaternions
(<code class="docutils literal notranslate"><span class="pre">AOATTQT{1,2,3,4}</span></code>) where the four values must be taken from the exact same readout
frame.</p>
<p>In order to force the MAUDE server to return full resolution data, the MAUDE data source
needs to be configured with the <code class="docutils literal notranslate"><span class="pre">allow_subset=False</span></code> flag.  This will prevent
sub-sampling by doing multiple small queries.  This has an overhead penalty because it may
require multiple server requests to piece together the full query.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">maude</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maude</span><span class="o">.</span><span class="n">set_logger_level</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># Show debugging information from maude</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;maude allow_subset=False&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;aoattqt1&#39;</span><span class="p">,</span> <span class="s1">&#39;2016:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2016:003&#39;</span><span class="p">)</span>
<span class="go">get_msids: Using .netrc with user=taldcroft</span>
<span class="go">get_msids_in_chunks: Chunked reading: max samples / major_frame = 32, chunk dt = 82000.0 secs</span>
<span class="go">get_msids: Getting URL http://t...cfa.harvard.edu/...&amp;ts=2016001120000000&amp;tp=2016002040000000</span>
<span class="go">get_msids: Getting URL http://t...cfa.harvard.edu/...&amp;ts=2016002040000000&amp;tp=2016002200000000</span>
<span class="go">get_msids: Getting URL http://t...cfa.harvard.edu/...&amp;ts=2016002200000000&amp;tp=2016003120000000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span>
<span class="go">168586  # MORE than 100000!</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">allow_subset=False</span></code> then a fetch query is not allowed to span more than 7 days in
order to prevent swamping the MAUDE server.</p>
<p><strong>Multiple data sources</strong></p>
<p>A common use case (indeed a key driver for accessing MAUDE through the Ska interface) is
to fetch data using <em>both</em> the CXC and MAUDE data, taking CXC data where possible and then
filling in the last couple of days using MAUDE with full-resolution data (no subsetting).
This is done by specifying the data source as both <code class="docutils literal notranslate"><span class="pre">cxc</span></code> and <code class="docutils literal notranslate"><span class="pre">maude</span>
<span class="pre">allow_subset=False</span></code>, as shown in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;cxc&#39;</span><span class="p">,</span> <span class="s1">&#39;maude allow_subset=False&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now assume the current date is 2016:152:01:00:00 and we want all available data since 2016:100</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2016:100&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data_source</span>
<span class="go">{&#39;cxc&#39;: {&#39;start&#39;: &#39;2016:100:12:00:11.268&#39;,</span>
<span class="go">         &#39;stop&#39;: &#39;2016:150:19:38:40.317&#39;},</span>
<span class="go"> &#39;maude&#39;: {&#39;flags&#39;: {&#39;subset&#39;: False, &#39;tolerance&#39;: False},</span>
<span class="go">           &#39;start&#39;: &#39;2016:150:19:38:56.130&#39;,</span>
<span class="go">           &#39;stop&#39;: &#39;2016:151:20:40:37.392&#39;}}</span>
</pre></div>
</div>
<p>This shows that data have been fetched from both data sources and stitched together
seamlessly.</p>
</div>
<div class="section" id="context-manager">
<h3>Context manager<a class="headerlink" href="#context-manager" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">fetch.data_source</span></code> object can also be used as a context manager to <em>temporarily</em>
change the data source within an enclosed code block.  This is useful because it restores
the original data source even if there is an exception within the code block.  For
instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span>
<span class="go">(&#39;cxc&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="p">(</span><span class="s1">&#39;maude&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2016:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2016:002&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">(&#39;maude&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span>
<span class="go">(&#39;cxc&#39;,)</span>
</pre></div>
</div>
</div>
<div class="section" id="data-source-differences">
<h3>Data source differences<a class="headerlink" href="#data-source-differences" title="Permalink to this headline">¶</a></h3>
<p>There are different MSIDs available in the different data sources (but <em>mostly</em> they
overlap).  To directly understand this you can access the MSID lists as follows.  The
<code class="docutils literal notranslate"><span class="pre">get_msids()</span></code> method of <code class="docutils literal notranslate"><span class="pre">data_source</span></code> returns a Python <code class="docutils literal notranslate"><span class="pre">set</span></code> of MSIDs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cxc_msids</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">get_msids</span><span class="p">(</span><span class="s1">&#39;cxc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maude_msids</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">data_source</span><span class="o">.</span><span class="n">get_msids</span><span class="p">(</span><span class="s1">&#39;maude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">cxc_msids</span> <span class="o">-</span> <span class="n">maude_msids</span><span class="p">)</span>  <span class="c1"># In CXC but not MAUDE</span>
<span class="go">[&#39;3W00FILL&#39;,</span>
<span class="go"> &#39;3W05FILL&#39;,</span>
<span class="go"> &#39;3W22FILL&#39;,</span>
<span class="go"> ...</span>
<span class="go"> &#39;TMP_FEP1_MONG&#39;,</span>
<span class="go"> &#39;TMP_FEP1_PCB&#39;,</span>
<span class="go"> &#39;TMP_FEP1_RAM&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">cxc_msids</span> <span class="o">-</span> <span class="n">maude_msids</span><span class="p">)</span>
<span class="go">552</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">maude_msids</span> <span class="o">-</span> <span class="n">cxc_msids</span><span class="p">)</span>
<span class="go">5107</span>
</pre></div>
</div>
<p>If you do a mixed-source query (CXC and MAUDE) for an MSID that is available in
only one of the sources, then just the one source will be used.  For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;pitch&#39;</span><span class="p">,</span> <span class="s1">&#39;2016:145&#39;</span><span class="p">)</span>  <span class="c1"># from 2016:145 to present</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">data_source</span>
<span class="go">{&#39;cxc&#39;: {&#39;start&#39;: &#39;2016:145:12:00:00.241&#39;,</span>
<span class="go">         &#39;stop&#39;: &#39;2016:150:18:37:01.841&#39;}}</span>
</pre></div>
</div>
</div>
<div class="section" id="setup-for-maude-authentication">
<h3>Setup for MAUDE authentication<a class="headerlink" href="#setup-for-maude-authentication" title="Permalink to this headline">¶</a></h3>
<p>In order to use MAUDE as the data source you must have authentication credentials
(username and password) to access OCCweb.  One can provide those credentials manually to
the <code class="xref py py-func docutils literal notranslate"><span class="pre">get_msids()</span></code> function call, but this gets tiresome.</p>
<p>The preferred method to use this from a secure machine is to edit the file <code class="docutils literal notranslate"><span class="pre">.netrc</span></code> in
your home directory and put in your OCCweb credentials.</p>
<p><strong>IMPORTANT</strong>: make sure the file is readable only by you!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chmod</span> <span class="n">og</span><span class="o">-</span><span class="n">rwx</span> <span class="o">~/.</span><span class="n">netrc</span>
</pre></div>
</div>
<p>Once you have done that, add these three lines.  If there are already
other machines defined you need a blank line between the machine configs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">machine</span>  <span class="n">occweb</span>
<span class="n">login</span>    <span class="n">your</span><span class="o">-</span><span class="n">occweb</span><span class="o">-</span><span class="n">username</span>
<span class="n">password</span> <span class="n">your</span><span class="o">-</span><span class="n">occweb</span><span class="o">-</span><span class="n">password</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pushing-it-to-the-limit">
<h2>Pushing it to the limit<a class="headerlink" href="#pushing-it-to-the-limit" title="Permalink to this headline">¶</a></h2>
<p>The engineering telemetry archive is designed to help answer questions that
require big datasets.  Let’s explore what is possible.  First quit from your
current <code class="docutils literal notranslate"><span class="pre">ipython</span></code> session with <code class="docutils literal notranslate"><span class="pre">exit()</span></code>.  Then start a window that will let
you watch memory usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xterm</span> <span class="o">-</span><span class="n">geometry</span> <span class="mi">80</span><span class="n">x15</span> <span class="o">-</span><span class="n">e</span> <span class="s1">&#39;top -u &lt;username&gt;&#39;</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>This brings up a text-based process monitor.  Focus on that window and hit “M”
to tell it to order by memory usage.  Now go back to your main window and get
all the <code class="docutils literal notranslate"><span class="pre">TEIO</span></code> data for the mission:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipython</span> <span class="o">--</span><span class="n">matplotlib</span>
<span class="kn">import</span> <span class="nn">Ska.engarchive.fetch</span> <span class="k">as</span> <span class="nn">fetch</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">Ska.Matplotlib</span> <span class="kn">import</span> <span class="n">plot_cxctime</span>
<span class="n">time</span> <span class="n">teio</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;teio&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="n">CPU</span> <span class="n">times</span><span class="p">:</span> <span class="n">user</span> <span class="mf">2.08</span> <span class="n">s</span><span class="p">,</span> <span class="n">sys</span><span class="p">:</span> <span class="mf">0.49</span> <span class="n">s</span><span class="p">,</span> <span class="n">total</span><span class="p">:</span> <span class="mf">2.57</span> <span class="n">s</span>
       <span class="n">Wall</span> <span class="n">time</span><span class="p">:</span> <span class="mf">2.85</span> <span class="n">s</span>
</pre></div>
</div>
<p>Now look at the memory usage and see that around a 1 Gb is being used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">teio</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e6</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plot_cxctime</span><span class="p">(</span><span class="n">teio</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">teio</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Making a plot with 13 million points takes 5 to 10 seconds and some memory.
See what happens to memory when you clear the plot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
</pre></div>
</div>
<p>Now let’s get serious and fetch all the AORATE3 values (1 per second) for the mission after deleting the TEIO data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">teio</span>
<span class="o">%</span><span class="n">time</span> <span class="n">aorate3</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSID</span><span class="p">(</span><span class="s1">&#39;aorate3&#39;</span><span class="p">,</span> <span class="s1">&#39;2000:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[]:</span> <span class="n">CPU</span> <span class="n">times</span><span class="p">:</span> <span class="n">user</span> <span class="mf">38.83</span> <span class="n">s</span><span class="p">,</span> <span class="n">sys</span><span class="p">:</span> <span class="mf">7.43</span> <span class="n">s</span><span class="p">,</span> <span class="n">total</span><span class="p">:</span> <span class="mf">46.26</span> <span class="n">s</span>
       <span class="n">Wall</span> <span class="n">time</span><span class="p">:</span> <span class="mf">60.10</span> <span class="n">s</span>
</pre></div>
</div>
<p>We just fetched 300 million floats and now <code class="docutils literal notranslate"><span class="pre">top</span></code> should be showing some respectable memory usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cpu</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>  <span class="mf">0.0</span><span class="o">%</span><span class="n">us</span><span class="p">,</span>  <span class="mf">0.1</span><span class="o">%</span><span class="n">sy</span><span class="p">,</span>  <span class="mf">0.0</span><span class="o">%</span><span class="n">ni</span><span class="p">,</span> <span class="mf">99.7</span><span class="o">%</span><span class="nb">id</span><span class="p">,</span>  <span class="mf">0.2</span><span class="o">%</span><span class="n">wa</span><span class="p">,</span>  <span class="mf">0.1</span><span class="o">%</span><span class="n">hi</span><span class="p">,</span>  <span class="mf">0.0</span><span class="o">%</span><span class="n">si</span><span class="p">,</span>  <span class="mf">0.0</span><span class="o">%</span><span class="n">st</span>

  <span class="n">PID</span> <span class="n">USER</span>      <span class="n">PR</span>  <span class="n">NI</span>  <span class="n">VIRT</span>  <span class="n">RES</span>  <span class="n">SHR</span> <span class="n">S</span> <span class="o">%</span><span class="n">CPU</span> <span class="o">%</span><span class="n">MEM</span>    <span class="n">TIME</span><span class="o">+</span>  <span class="n">COMMAND</span>
<span class="mi">14243</span> <span class="n">aca</span>       <span class="mi">15</span>   <span class="mi">0</span> <span class="mi">6866</span><span class="n">m</span> <span class="mf">6.4</span><span class="n">g</span>  <span class="mi">11</span><span class="n">m</span> <span class="n">S</span>  <span class="mf">0.0</span> <span class="mf">40.9</span>   <span class="mi">3</span><span class="p">:</span><span class="mf">08.70</span> <span class="n">ipython</span>
</pre></div>
</div>
<p>If you try to make a simple scatter plot with 300 million points you will
make the machine very unhappy.  But we can do computations or make a histogram of
the distribution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">aorate3</span><span class="o">.</span><span class="n">vals</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-15</span><span class="p">),</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/aorate3_hist.png" src="_images/aorate3_hist.png" />
<p>Rules of thumb:</p>
<ul class="simple">
<li><p>1 million is fast for plotting and analysis.</p></li>
<li><p>10 million is fast for analysis but on the edge for plotting:</p>
<ul>
<li><p>Plotting lines or symbols (the <code class="docutils literal notranslate"><span class="pre">'-'</span></code> or <code class="docutils literal notranslate"><span class="pre">'.'</span></code> markers) may fail with the dreaded <code class="docutils literal notranslate"><span class="pre">Agg</span>
<span class="pre">rendering</span> <span class="pre">complexity</span> <span class="pre">exceeded</span></code>.  Once this happens you frequently need to restart
IPython entirely to make more plots.</p></li>
<li><p>Plotting with the <code class="docutils literal notranslate"><span class="pre">','</span></code> marker is typically OK as this just makes a single pixel
dot instead of a plot glyph.</p></li>
</ul>
</li>
<li><p>300 million is OK for analysis, expect 30-60 seconds for any operation.  Plots can only
be done using density image maps binning in 2-d.</p></li>
<li><p>Look before you leap, do smaller fetches first and check sizes as shown below.</p></li>
<li><p>5-minute stats are ~10 million so you are always OK.</p></li>
</ul>
<div class="section" id="estimating-fetch-size">
<h3>Estimating fetch size<a class="headerlink" href="#estimating-fetch-size" title="Permalink to this headline">¶</a></h3>
<p>You can do a better than the above rules of thumb using the
<a class="reference internal" href="utils.html#Ska.engarchive.utils.get_fetch_size" title="Ska.engarchive.utils.get_fetch_size"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_fetch_size()</span></code></a> function in the <code class="docutils literal notranslate"><span class="pre">Ska.engarchive.utils</span></code>
module to estimate the size of a fetch request prior to making the call.  This is
especially useful for applications that want to avoid unreasonably large data requests.</p>
<p>As an example, compute the estimated size in Megabytes for fetching full-resolution data
for TEPHIN and AOPCADMD for a period of 3 years, both of which are then interpolated at a
time sampling of 32.8 seconds:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Ska.engarchive.utils</span> <span class="kn">import</span> <span class="n">get_fetch_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_fetch_size</span><span class="p">([</span><span class="s1">&#39;TEPHIN&#39;</span><span class="p">,</span> <span class="s1">&#39;AOPCADMD&#39;</span><span class="p">],</span> <span class="s1">&#39;2011:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2014:001&#39;</span><span class="p">,</span> <span class="n">interpolate_dt</span><span class="o">=</span><span class="mf">32.8</span><span class="p">)</span>
<span class="go">(1248.19, 75.06)</span>
</pre></div>
</div>
<p>This returns two numbers: the first is the memory (megabytes) for the internal fetch
operation to get the telemetry data, and the second is the memory for the interpolated
output.  This estimate is made by fetching a 3-day sample of data starting at 2010:001
and extrapolating.  Therefore the size estimates are reflective of normal operations.</p>
</div>
</div>
<div class="section" id="fetching-the-easy-way">
<h2>Fetching the easy way<a class="headerlink" href="#fetching-the-easy-way" title="Permalink to this headline">¶</a></h2>
<p>The high-level function <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.get_telem" title="Ska.engarchive.fetch.get_telem"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_telem()</span></code></a> is available to simplify use of the Ska engineering
archive.  It provides a way to combine many of the common processing steps associated with
fetching and using telemetry data into a single function call.  This includes:</p>
<ul class="simple">
<li><p>Fetch a set of MSIDs over a time range, specifying the sampling as
either full-resolution, 5-minute, or daily data.</p></li>
<li><p>Filter out bad or missing data.</p></li>
<li><p>Interpolate (resample) all MSID values to a common uniformly-spaced time sequence.</p></li>
<li><p>Remove or select time intervals corresponding to specified Kadi event types.</p></li>
<li><p>Change the time format from CXC seconds (seconds since 1998.0) to something more
convenient like GRETA time.</p></li>
<li><p>Write the MSID telemetry data to a zip file.</p></li>
</ul>
<p>Aside from the first two steps (fetching data and filtering bad data), all the steps are
optional.</p>
<p>The <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.get_telem" title="Ska.engarchive.fetch.get_telem"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_telem()</span></code></a> function has a lot of parameters in order to be flexible, but we’ll break
them down into manageable groups.</p>
<p><strong>Desired telemetry</strong></p>
<p>The first set are the key inputs relating to the actual telemetry:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>msids</p></td>
<td><p>MSID(s) to fetch (string or list of strings)</p></td>
</tr>
<tr class="row-odd"><td><p>start</p></td>
<td><p>Start time for data fetch (default=&lt;stop&gt; - 30 days)</p></td>
</tr>
<tr class="row-even"><td><p>stop</p></td>
<td><p>Stop time for data fetch (default=NOW)</p></td>
</tr>
<tr class="row-odd"><td><p>sampling</p></td>
<td><p>Data sampling (full | 5min | daily) (default=full)’)</p></td>
</tr>
<tr class="row-even"><td><p>unit_system</p></td>
<td><p>Unit system for data (eng | sci | cxc) (default=eng)</p></td>
</tr>
</tbody>
</table>
<p>The first argument <code class="docutils literal notranslate"><span class="pre">msids</span></code> is the only one that always has to be provided.  It should be
either a single string like <code class="docutils literal notranslate"><span class="pre">'COBSRQID'</span></code> or a list of strings like <code class="docutils literal notranslate"><span class="pre">['TEPHIN',</span>
<span class="pre">'TCYLAFT6',</span> <span class="pre">'TEIO']</span></code>.  Note that the MSID is case-insensitive so <code class="docutils literal notranslate"><span class="pre">'tephin'</span></code> is fine.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> arguments are typically a string like <code class="docutils literal notranslate"><span class="pre">'2012:001:02:03:04'</span></code>
(ISO time) or <code class="docutils literal notranslate"><span class="pre">'2012001.020304'</span></code> (GRETA time).  If not provided then the last 30 days of
telemetry will be fetched.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sampling</span></code> argument will choose between either full-resolution telemetry
or the 5-minute or daily summary statistic values.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">unit_system</span></code> argument selects the output unit system.  The choices are engineering
units (i.e. what is in the TDB and GRETA), science units (mostly just temperatures in C
instead of F), or CXC units (whatever is in CXC decom, which e.g. has temperatures in K).</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">ska</span>
<span class="o">%</span> <span class="n">ipython</span> <span class="o">--</span><span class="n">pylab</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Ska.engarchive.fetch</span> <span class="kn">import</span> <span class="n">get_telem</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dat</span> <span class="o">=</span> <span class="n">get_telem</span><span class="p">([</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;tcylaft6&#39;</span><span class="p">],</span> <span class="s1">&#39;2010:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2010:030&#39;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="s1">&#39;5min&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clf</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dat</span><span class="p">[</span><span class="s1">&#39;tephin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;TEPHIN&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dat</span><span class="p">[</span><span class="s1">&#39;tcylaft6&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;TCYLAFT6&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<p>The output of <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.get_telem" title="Ska.engarchive.fetch.get_telem"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_telem()</span></code></a> is an <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a> object which is described in the <a class="reference internal" href="#msid-sets">MSID
sets</a> section.</p>
<p><strong>Interpolation</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>interpolate_dt</p></td>
<td><p>Interpolate to uniform time steps (secs, default=None)</p></td>
</tr>
</tbody>
</table>
<p>In general different MSIDs will come down in telemetry with different sampling and time
stamps.  Interpolation allows you to put all the MSIDs onto a common time sequence so you
can compare them, plot one against the other, and so forth.  You can see the
<a class="reference internal" href="#interpolation">Interpolation</a> section for the gory details, but if you need to have your MSIDs on
a common time sequence then set <code class="docutils literal notranslate"><span class="pre">interpolate_dt</span></code> to the desired time step
in seconds.  When interpolating <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.get_telem" title="Ska.engarchive.fetch.get_telem"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_telem()</span></code></a> uses <code class="docutils literal notranslate"><span class="pre">filter_bad=True</span></code> and
<code class="docutils literal notranslate"><span class="pre">union_bad=True</span></code> (as described in <a class="reference internal" href="#interpolation">Interpolation</a>).</p>
<p><strong>Intervals</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>remove_events</p></td>
<td><p>Remove kadi events expression (default=None)</p></td>
</tr>
<tr class="row-odd"><td><p>select_events</p></td>
<td><p>Select kadi events expression (default=None)</p></td>
</tr>
</tbody>
</table>
<p>These arguments allow you to select or remove intervals in the data using the <a class="reference external" href="http://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc/kadi/#event-definitions">Kadi event
definitions</a>.
For instance we can select times of stable NPM dwells during radiation zones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">get_telem</span><span class="p">([</span><span class="s1">&#39;aoatter1&#39;</span><span class="p">,</span> <span class="s1">&#39;aoatter2&#39;</span><span class="p">,</span> <span class="s1">&#39;aoatter3&#39;</span><span class="p">],</span>
<span class="go">                    start=&#39;2014:001&#39;, stop=&#39;2014:010&#39;, interpolate_dt=32.8,</span>
<span class="go">                    select_events=&#39;dwells &amp; rad_zones&#39;)</span>
</pre></div>
</div>
<p>The order of processing is to first remove event intervals, then select event intervals.</p>
<p>The expression for <code class="docutils literal notranslate"><span class="pre">remove_events</span></code> or <code class="docutils literal notranslate"><span class="pre">select_events</span></code> can be any logical expression
involving Kadi query names (see the <a class="reference external" href="http://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc/kadi/#event-definitions">event definitions table</a>).  The
following string would be valid: <code class="docutils literal notranslate"><span class="pre">'dsn_comms</span> <span class="pre">|</span> <span class="pre">(dwells[pad=-300]</span> <span class="pre">&amp;</span> <span class="pre">~eclipses)'</span></code>, and for
<code class="docutils literal notranslate"><span class="pre">select_events</span></code> this would imply selecting telemetry which is either during a DSN pass
or (within a NPM dwell and not during an eclipse).  The <code class="docutils literal notranslate"><span class="pre">[pad=-300]</span></code> qualifier means
that a buffer of 300 seconds is applied on each edge to provide padding from the maneuver.
A positive padding expands the event intervals while negative contracts the intervals.</p>
<p><strong>Output</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>time_format</p></td>
<td><p>Output time format (secs|date|greta|jd|…, default=secs)</p></td>
</tr>
<tr class="row-odd"><td><p>outfile</p></td>
<td><p>Output file name (default=None)</p></td>
</tr>
</tbody>
</table>
<p>By default the <code class="docutils literal notranslate"><span class="pre">times</span></code> attribute for each MSID is provided in seconds since 1998.0 (CXC
seconds).  The <code class="docutils literal notranslate"><span class="pre">time_format</span></code> argument allows selecting any time format supported by
<a class="reference external" href="http://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc/pydocs/Chandra.Time.html">Chandra.Time</a>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">outfile</span></code> is set to a valid file name then the MSID set will be written out as a
compressed zip archive.  This archive will contain a CSV file corresponding to each MSID
in the set.  See the section on <a class="reference internal" href="#exporting-to-csv">Exporting to CSV</a> for additional information and an
example of the output format.</p>
<p><strong>Process control</strong></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>quiet</p></td>
<td><p>Suppress run-time logging output (default=False)</p></td>
</tr>
<tr class="row-odd"><td><p>max_fetch_Mb</p></td>
<td><p>Max allowed memory (Mb) for fetching (default=1000)</p></td>
</tr>
<tr class="row-even"><td><p>max_output_Mb</p></td>
<td><p>Max allowed memory (Mb) for output (default=100)</p></td>
</tr>
</tbody>
</table>
<p>Normally <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.get_telem" title="Ska.engarchive.fetch.get_telem"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_telem()</span></code></a> outputs a few lines of progress information as it is processing the
request.  To disable this logging set <code class="docutils literal notranslate"><span class="pre">quiet=True</span></code>.</p>
<p>The next two arguments are in place to prevent accidentally doing a huge query that will
consume all available memory or generate a large file that will be slow to read.  For
instance getting all the gyro count data for the mission will take more than 70 Gb of
memory.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">max_fetch_Mb</span></code> argument specifies how much memory the fetched <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a> can
take.  This has a default of 1000 Mb = 1 Gb.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">max_output_Mb</span></code> only applies if you have also specified an <code class="docutils literal notranslate"><span class="pre">outfile</span></code> to write.
This checks the size of the actual output <a class="reference internal" href="fetch.html#Ska.engarchive.fetch.MSIDset" title="Ska.engarchive.fetch.MSIDset"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSIDset()</span></code></a>, which may be smaller than the
fetch object if data sampling has been reduced via the <code class="docutils literal notranslate"><span class="pre">interpolate_dt</span></code> argument.  This
has a default of 100 Mb.</p>
<p>Both of the defaults here are relatively conservative, and with experience you can set
larger values.</p>
</div>
<div class="section" id="putting-it-all-together">
<h2>Putting it all together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">¶</a></h2>
<p>As a final example here is a real-world problem of wanting to compare OBC
rates to those derived on the ground using raw gyro data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Ska.engarchive.fetch</span> <span class="k">as</span> <span class="nn">fetch</span>
<span class="kn">from</span> <span class="nn">Ska.Matplotlib</span> <span class="kn">import</span> <span class="n">plot_cxctime</span>
<span class="kn">import</span> <span class="nn">Ska.Numpy</span>

<span class="n">tstart</span> <span class="o">=</span> <span class="s1">&#39;2009:313:16:00:00&#39;</span>
<span class="n">tstop</span> <span class="o">=</span> <span class="s1">&#39;2009:313:17:00:00&#39;</span>

<span class="c1"># Get OBC rates and gyro counts</span>
<span class="n">obc</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aorate1&#39;</span><span class="p">,</span> <span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;aorate3&#39;</span><span class="p">],</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">gyr</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">MSIDset</span><span class="p">([</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">,</span> <span class="s1">&#39;aogyrct2&#39;</span><span class="p">,</span> <span class="s1">&#39;aogyrct3&#39;</span><span class="p">,</span> <span class="s1">&#39;aogyrct4&#39;</span><span class="p">],</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">filter_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Transform delta gyro counts (4 channels) to a body rate (3 axes)</span>
<span class="n">cts2rate</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.5</span>       <span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span>       <span class="p">],</span>
                  <span class="p">[</span><span class="o">-</span><span class="mf">0.25623091</span><span class="p">,</span>  <span class="mf">0.60975037</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25623091</span><span class="p">,</span>  <span class="mf">0.60975037</span><span class="p">],</span>
                  <span class="p">[</span><span class="o">-</span><span class="mf">0.55615682</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05620959</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.55615682</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05620959</span><span class="p">]])</span>

<span class="c1"># Calculate raw spacecraft rate directly from gyro data</span>
<span class="n">cts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span>
                <span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span>
                <span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span>
                <span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct4&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span><span class="p">])</span>
<span class="n">raw_times</span> <span class="o">=</span> <span class="p">(</span><span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">delta_times</span> <span class="o">=</span> <span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">gyr</span><span class="p">[</span><span class="s1">&#39;aogyrct1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">delta_cts</span> <span class="o">=</span> <span class="n">cts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">cts</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">raw_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cts2rate</span><span class="p">,</span> <span class="n">delta_cts</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.02</span> <span class="o">/</span> <span class="n">delta_times</span>

<span class="c1"># Plot the OBC rates</span>
<span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">clf</span><span class="p">()</span>
<span class="k">for</span> <span class="n">frame</span><span class="p">,</span> <span class="n">msid</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;aorate1&#39;</span><span class="p">,</span> <span class="s1">&#39;roll&#39;</span><span class="p">),</span>
                           <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;aorate2&#39;</span><span class="p">,</span> <span class="s1">&#39;pitch&#39;</span><span class="p">),</span>
                           <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;aorate3&#39;</span><span class="p">,</span> <span class="s1">&#39;yaw&#39;</span><span class="p">)):</span>
    <span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="n">obc_rates</span> <span class="o">=</span> <span class="n">obc</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">vals</span> <span class="o">*</span> <span class="mf">206254.</span>
    <span class="n">plot_cxctime</span><span class="p">(</span><span class="n">obc</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">obc_rates</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plot_cxctime</span><span class="p">(</span><span class="n">obc</span><span class="p">[</span><span class="n">msid</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">Ska</span><span class="o">.</span><span class="n">Numpy</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">obc_rates</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="s1">&#39;-r&#39;</span><span class="p">)</span>
    <span class="n">ylim</span><span class="p">(</span><span class="n">average</span><span class="p">(</span><span class="n">obc_rates</span><span class="p">)</span> <span class="o">+</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]))</span>
    <span class="n">title</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; rate (arcsec/sec)&#39;</span><span class="p">)</span>

<span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.90</span><span class="p">)</span>
<span class="c1"># savefig(&#39;obc_rates.png&#39;)</span>

<span class="c1"># Plot the S/C rates from raw gyro data</span>
<span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">clf</span><span class="p">()</span>
<span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;roll&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;pitch&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;yaw&#39;</span><span class="p">)):</span>
    <span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">raw_rate</span> <span class="o">=</span> <span class="n">raw_rates</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">plot_cxctime</span><span class="p">(</span><span class="n">raw_times</span><span class="p">,</span> <span class="n">raw_rate</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">plot_cxctime</span><span class="p">(</span><span class="n">raw_times</span><span class="p">,</span> <span class="n">Ska</span><span class="o">.</span><span class="n">Numpy</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">raw_rate</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="s1">&#39;-r&#39;</span><span class="p">)</span>
    <span class="n">ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">raw_rate</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]))</span>
    <span class="n">title</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; S/C rate (arcsec/sec)&#39;</span><span class="p">)</span>

<span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.90</span><span class="p">)</span>
<span class="c1"># savefig(&#39;gyro_sc_rates.png&#39;)</span>
</pre></div>
</div>
<img alt="_images/obc_rates.png" src="_images/obc_rates.png" />
<img alt="_images/gyro_sc_rates.png" src="_images/gyro_sc_rates.png" />
</div>
<div class="section" id="remote-data-access">
<h2>Remote data access<a class="headerlink" href="#remote-data-access" title="Permalink to this headline">¶</a></h2>
<p>The telemetry archive can be accessed remotely if ssh access to
<code class="docutils literal notranslate"><span class="pre">chimchim</span></code> is available.  The user will be queried for ssh credentials and
<code class="docutils literal notranslate"><span class="pre">fetch</span></code> will connect with a controller running on <code class="docutils literal notranslate"><span class="pre">chimchim</span></code> to retrieve the
data.  Besides the initial query for credentials (and slower speeds when fetching data over
the network), the use of <code class="docutils literal notranslate"><span class="pre">fetch</span></code> is essentially the same whether the archive is
local or remote.</p>
<p>In order to use this option, the user must have a special key file
<code class="docutils literal notranslate"><span class="pre">ska_remote_access.json</span></code> placed at the root of the local Python installation
folder.  This is placed in the directory shown with <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">sys;</span>
<span class="pre">print(sys.prefix)</span></code>.</p>
<p>To get a copy of this file contact Mark Baski or Tom Aldcroft, or look in the
<code class="docutils literal notranslate"><span class="pre">DAWG_TIPS_AND_TRICKS</span></code> topic in the <code class="docutils literal notranslate"><span class="pre">SpecialProjects</span></code> Web on the TWiki.</p>
<p>Remote access is controlled as follows:</p>
<ul class="simple">
<li><p>The environment variable <code class="docutils literal notranslate"><span class="pre">SKA_ACCESS_REMOTELY</span></code> can be set to “False” or “True”
to force either disabling or enabling remote access, respectively.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">SKA_ACCESS_REMOTELY</span></code> is not defined on a linux or Mac system, remote access
is always <em>disabled</em>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">SKA_ACCESS_REMOTELY</span></code> is not defined on a Windows system, remote access
is <em>enabled</em> unless the system finds a local engineering data archive.  It looks
for data in either <code class="docutils literal notranslate"><span class="pre">$SKA/data/eng_archive</span></code> or <code class="docutils literal notranslate"><span class="pre">$ENG_ARCHIVE</span></code>, where those
refer to user-defined environment variables.</p></li>
<li><p>If remote access is disabled and there is no local engineering data archive,
then a warning is issued. In this case you can still use MAUDE for data access
with <code class="docutils literal notranslate"><span class="pre">fetch.data_source.set('maude')</span></code>.</p></li>
</ul>
<div class="section" id="scripts-using-remote-access">
<h3>Scripts using remote access<a class="headerlink" href="#scripts-using-remote-access" title="Permalink to this headline">¶</a></h3>
<p>If you are using remote data access from within a script, you should write the
script using calls to functions instead of having everything at the main level.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cheta</span> <span class="kn">import</span> <span class="n">fetch</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># For remote access this will interactively prompt the user for an</span>
    <span class="c1"># IP address, user name and password (for only the first fetch).</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2020:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2020:002&#39;</span><span class="p">)</span>

    <span class="c1"># Now do something with dat</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>The reason for this is that the code which accesses the remote server may end
up importing the main script many times, so if you have non-trivial code at the
top level this causes problems. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># DO NOT DO THIS</span>
<span class="kn">from</span> <span class="nn">cheta</span> <span class="kn">import</span> <span class="n">fetch</span>

<span class="c1"># This line gets run multiple times in succession via multiprocessing: FAIL</span>
<span class="n">dat</span> <span class="o">=</span> <span class="n">fetch</span><span class="o">.</span><span class="n">Msid</span><span class="p">(</span><span class="s1">&#39;tephin&#39;</span><span class="p">,</span> <span class="s1">&#39;2020:001&#39;</span><span class="p">,</span> <span class="s1">&#39;2020:002&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>These problems are known to happen on Windows, but following this best practice
should be done for all remote-access scripts.</p>
</div>
</div>
<div class="section" id="local-cheta-archive">
<h2>Local cheta archive<a class="headerlink" href="#local-cheta-archive" title="Permalink to this headline">¶</a></h2>
<p>Instructions for creating, using, and maintaining a local cheta archive (on your
laptop for instance) are found at the <a class="reference external" href="https://github.com/sot/eng_archive/wiki/Tutorial:-install-and-maintain-cheta-telemetry-archive">Tutorial for installing and maintaining a
cheta telemetry archive</a>.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/ska.png" alt="Logo"/>
            </a></p><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Fetch Tutorial</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#date-and-time-formats">Date and time formats</a></li>
<li><a class="reference internal" href="#exporting-to-csv">Exporting to CSV</a></li>
<li><a class="reference internal" href="#plotting-time-data">Plotting time data</a></li>
<li><a class="reference internal" href="#interactive-plotting">Interactive plotting</a></li>
<li><a class="reference internal" href="#data-filtering">Data filtering</a><ul>
<li><a class="reference internal" href="#event-interval-filtering">Event interval filtering</a></li>
<li><a class="reference internal" href="#bad-data">Bad data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#five-minute-and-daily-stats">Five minute and daily stats</a></li>
<li><a class="reference internal" href="#msid-sets">MSID sets</a><ul>
<li><a class="reference internal" href="#interpolation">Interpolation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unit-systems">Unit systems</a><ul>
<li><a class="reference internal" href="#mixing-units">Mixing units</a></li>
</ul>
</li>
<li><a class="reference internal" href="#msid-globs">MSID globs</a></li>
<li><a class="reference internal" href="#state-valued-msids">State-valued MSIDs</a><ul>
<li><a class="reference internal" href="#state-value-counts">State value counts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#telemetry-database">Telemetry database</a></li>
<li><a class="reference internal" href="#maude-telemetry-server">MAUDE telemetry server</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#context-manager">Context manager</a></li>
<li><a class="reference internal" href="#data-source-differences">Data source differences</a></li>
<li><a class="reference internal" href="#setup-for-maude-authentication">Setup for MAUDE authentication</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pushing-it-to-the-limit">Pushing it to the limit</a><ul>
<li><a class="reference internal" href="#estimating-fetch-size">Estimating fetch size</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fetching-the-easy-way">Fetching the easy way</a></li>
<li><a class="reference internal" href="#putting-it-all-together">Putting it all together</a></li>
<li><a class="reference internal" href="#remote-data-access">Remote data access</a><ul>
<li><a class="reference internal" href="#scripts-using-remote-access">Scripts using remote access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#local-cheta-archive">Local cheta archive</a></li>
</ul>
</li>
</ul>


  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial.html"
                        title="previous chapter">Ska Analysis Tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ska_fetch.html"
                        title="next chapter">Command-line fetch</a></p>
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011, Tom Aldcroft.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.1.2. &nbsp;
  </p>
</footer>
  </body>
</html>